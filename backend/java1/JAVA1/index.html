<!DOCTYPE html>
<html lang="zh_CN" data-theme-mode="dark" data-light-theme="Savor" data-dark-theme="Dark-Blue">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="stylesheet" type="text/css" id="baseStyle" href="stage/build/export/base.css?2.12.3"/>
    <link rel="stylesheet" type="text/css" id="themeDefaultStyle" href="appearance/themes/Dark-Blue/theme.css?2.12.3"/>
    <link rel="stylesheet" type="text/css" id="themeStyle" href="appearance/themes/Dark-Blue/theme.css?2.12.3"/>
    <title>E:\changhuiengineer\backend\java1\JAVA1 - 思源笔记  v2.12.3</title>
    <style>
        body {font-family: var(--b3-font-family);background-color: var(--b3-theme-background);color: var(--b3-theme-on-background)}
        .b3-typography, .protyle-wysiwyg, .protyle-title {font-size:16px !important}
.b3-typography code:not(.hljs), .protyle-wysiwyg span[data-type~=code] { font-variant-ligatures: none }
.li > .protyle-action {height:34px;line-height: 34px}
.protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h1, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h2, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h3, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h4, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h5, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h6 {line-height:34px;}
.protyle-wysiwyg [data-node-id].li > .protyle-action:after {height: 16px;width: 16px;margin:-8px 0 0 -8px}
.protyle-wysiwyg [data-node-id].li > .protyle-action svg {height: 14px}
.protyle-wysiwyg [data-node-id].li:before {height: calc(100% - 34px);top:34px}
.protyle-wysiwyg [data-node-id] [spellcheck] {min-height:26px;}
.protyle-wysiwyg [data-node-id] {}
.protyle-wysiwyg .li {min-height:34px}
.protyle-gutters button svg {height:26px}
.protyle-wysiwyg img.emoji, .b3-typography img.emoji {width:18px}
.protyle-wysiwyg .h1 img.emoji, .b3-typography h1 img.emoji {width:35px}
.protyle-wysiwyg .h2 img.emoji, .b3-typography h2 img.emoji {width:31px}
.protyle-wysiwyg .h3 img.emoji, .b3-typography h3 img.emoji {width:27px}
.protyle-wysiwyg .h4 img.emoji, .b3-typography h4 img.emoji {width:25px}
.protyle-wysiwyg .h5 img.emoji, .b3-typography h5 img.emoji {width:22px}
.protyle-wysiwyg .h6 img.emoji, .b3-typography h6 img.emoji {width:20px}
        

.importer-topbar-icon{width:12px;height:12px}html[data-light-theme=Savor] .importer-topbar-icon,html[data-dark-theme=Savor] .importer-topbar-icon{width:16px;height:15px;margin-top:-4px;margin-left:-2px}.importer-menu-icon{width:12px;height:12px;margin-right:10px;margin-top:3px}.importer-form-container.svelte-c3a8hl .config__tab-container.svelte-c3a8hl{height:unset}.selected.svelte-c3a8hl.svelte-c3a8hl{color:red;padding:0 4px}.highlight.svelte-c3a8hl.svelte-c3a8hl{color:red}.link.svelte-c3a8hl.svelte-c3a8hl{color:var(--b3-theme-primary);cursor:pointer}.tips.svelte-c3a8hl.svelte-c3a8hl{cursor:pointer}.b3-label__text.svelte-c3a8hl .sign.svelte-c3a8hl{cursor:pointer;color:var(--b3-theme-primary)}.highlight.hidden.svelte-c3a8hl.svelte-c3a8hl,.sign.hidden.svelte-c3a8hl.svelte-c3a8hl{display:none}.test-data-item.svelte-15pkbbz{margin:4px 0}.pull-right.svelte-15pkbbz{float:right}.hidden.svelte-15pkbbz{display:none}
#helloPanel{border:1px rgb(189,119,119) dashed}
.b3-list-item__text.svelte-15drd7h{margin-right:.5em}.visible.svelte-2m76cy{overflow:visible}.fn__block.b3-switch.svelte-edt8og{overflow:visible;padding-left:1em}.fn__block.b3-slider.svelte-edt8og{padding:0}label.svelte-1l7osn9{width:unset;margin:.5em 0}.content.svelte-x3hvqm .protyle-breadcrumb.svelte-x3hvqm{height:32px}.content.svelte-x3hvqm .protyle-breadcrumb .address-field.svelte-x3hvqm{margin:4px}.content.svelte-x3hvqm .protyle-preview.svelte-x3hvqm{user-select:none}.content.svelte-x3hvqm .webview-status.svelte-x3hvqm{position:absolute;bottom:0;left:0}.pointer-events-disable.svelte-x3hvqm.svelte-x3hvqm{pointer-events:none}

        
    </style>
</head>
<body>
<div class="b3-typography" 
style="max-width: 800px;margin: 0 auto;" 
id="preview"><h1 id="20240124005414-o0lawqj" updated="20240124005414">JAVA1</h1>
<h2 id="20240124005414-bvwkhbz" updated="20240124005414">JAVA简介</h2>
<h3 id="20240124005414-wdc5nvm" updated="20240124005414">JAVA的由来</h3>
<p id="20240124005414-x7vpv05" updated="20240124005414">JAVA 最初是由任职于太阳微系统的詹姆斯-高斯林（James-Gosling）等人于1990年代初开发。他最初被命名为Oak；当时发现Oak被其他公司注册了，不得不重新起名，当时他们正在咖啡馆喝着印尼爪哇（JAVA）岛出产的咖啡，有人提议就叫JAVA怎么样，然后他们就把这种程序语言命名为JAVA。1994年网警公司推出了一种叫做Netscape的浏览器，加速了互联网的普及；高斯林他们就开始针对互联网做JAVA 应用，1995年高斯林参加“硅谷-好莱坞”互联网及娱乐业研讨会，演讲的时候高斯林江鼠标移向一个分子模型，这个模型动起来了，而且可以随着鼠标的移动上下翻滚。就这样，JAVA活下来了并且从1995年正式进入人们的视野。</p>
<h3 id="20240124005414-f96p3la" updated="20240124005414">JAVA的特性：安全  跨平台  虚拟机内运行 多线程</h3>
<h4 id="20240124005414-feokrri" updated="20240124005414">安全</h4>
<p id="20240124005414-xtzbgv2" updated="20240124005414">Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。除了 Java 语言具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以防替代本地的同名类，并包含安全管理机制。</p>
<h4 id="20240124005414-82x0193" updated="20240124005414">1. 面向对象</h4>
<p id="20240124005414-78oza2e" updated="20240124005414">Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。使用 Java 语言开发程序，需要采用面向对象的思想设计程序和编写代码。</p>
<h4 id="20240124005414-hav75g5" updated="20240124005414">多线程</h4>
<p id="20240124005414-z2rkp5y" updated="20240124005414">Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持多个线程同时执行，并提供多线程之间的同步机制。任何一个线程都有自己的 run() 方法，要执行的方法就写在 run() 方法体内。</p>
<p id="20240124005414-y0ecwxf" updated="20240124005414">其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。</p>
<h3 id="20240124005414-trgkifv" updated="20240124005414">运行机制JDK JRE</h3>
<p id="20240124005414-idt8qdd" updated="20240124005414">java程序并非直接运行在系统，而是运行在虚拟运行环境中jvm ，jvm可以在 多个平台运行 包括 Windows mac linux 平台。</p>
<p id="20240124005414-uvp0w3m" updated="20240124005414">JDK 是开发环境包 包括多个开发工具 ：</p>
<p id="20240124005414-7gtiniz" updated="20240124005414">javac – 编译器，将源程序转成字节码</p>
<p id="20240124005414-2vu6vzd" updated="20240124005414">jar – 打包工具，将相关的类文件打包成一个文件</p>
<p id="20240124005414-02smpz7" updated="20240124005414">javadoc – 文档生成器，从源码注释中提取文档</p>
<p id="20240124005414-1qga940" updated="20240124005414">jdb – debugger，查错工具</p>
<p id="20240124005414-nh2xl28" updated="20240124005414">java – 运行编译后的java程序（.class后缀的）</p>
<p id="20240124005414-50209ln" updated="20240124005414">appletviewer：小程序浏览器，一种执行<a href="https://baike.baidu.com/item/HTML文件?fromModule=lemma_inlink">HTML文件</a>上的Java小程序的Java浏览器。</p>
<p id="20240124005414-x1qrswf" updated="20240124005414">Javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件。</p>
<p id="20240124005414-iyh0ak6" updated="20240124005414">Javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示<a href="https://baike.baidu.com/item/字节代码?fromModule=lemma_inlink">字节代码</a>含义。</p>
<p id="20240124005414-sucdxyc" updated="20240124005414">Jconsole: Java进行系统调试和监控的工具</p>
<p id="20240124005414-xzr5i1p" updated="20240124005414">​<span class="img"><img src="assets/image_-gy9Sz1LrL-20240121141758-mkc35xm.png" alt="image_-gy9Sz1LrL.png" /></span>​</p>
<p id="20240124005414-0n7bi8m" updated="20240124005414">图1-1 jdk结构图</p>
<p id="20240124005414-r10407p" updated="20240124005414">JRE是运行环境，但是不包含开发其他开发工具</p>
<h3 id="20240124005414-k0gdbpr" updated="20240124005414">Java语言的特点</h3>
<p id="20240124005414-pcg3j22" updated="20240124005414">Java 语言的风格很像 C 语言和 <a href="http://c.biancheng.net/cplus/">C++</a> 语言，是一种纯粹的面向对象语言，它继承了 C++ 语言面向对象的技术核心，但是拋弃了 C++ 的一些缺点，比如说容易引起错误的指针以及多继承等，同时也增加了垃圾回收机制，释放掉不被使用的内存空间，解决了管理内存空间的烦恼。</p>
<p id="20240124005414-kqerhhn" updated="20240124005414">Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。</p>
<p id="20240124005414-2s615hs" updated="20240124005414"><span class="img"><img src="assets/image_ojzyputaMC-20240121141758-fdo1qbd.png" alt="image_ojzyputaMC.png" /></span></p>
<h3 id="20240124005414-2nwbsku" updated="20240124005414">JAVA运行原理</h3>
<p id="20240124005414-xq5qtts" updated="20240124005414"><span class="img"><img src="assets/image-20240121141758-1gn3w11.png" alt="image.png" /></span></p>
<p id="20240124005414-ceyk5a1" updated="20240124005414">JAVA三种技术架构介绍</p>
<p id="20240124005414-9lrfitw" updated="20240124005414">按应用范围，Java 可分为 3 个体系，即 Java SE、Java EE 和 Java ME。下面简单介绍这 3 个体系。</p>
<ol id="20240124005414-4qlwo3d" updated="20240124005414">
<li id="20240124005414-e7dtx4z" updated="20240124005414">
<p id="20240124005414-rle9hc1" updated="20240124005414">Java SE</p>
</li>
</ol>
<p id="20240124005414-e3j8pa1" updated="20240124005414">Java SE（Java Platform Standard Edition，Java 平台标准版）以前称为 J2SE，它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java EE 提供基础，如 Java 语言基础、JDBC 操作、I/O 操作、网络通信以及多线程等技术。图 1 所示为 Java SE 的体系结构。</p>
<p id="20240124005414-knnactn" updated="20240124005414">Java SE的体系结构</p>
<p id="20240124005414-5xbe9cv" updated="20240124005414">图1-2 Java SE</p>
<ol id="20240124005414-u9vekc5" updated="20240124005414">
<li id="20240124005414-3gd2541" updated="20240124005414">
<p id="20240124005414-07t9pf7" updated="20240124005414">Java EE</p>
</li>
</ol>
<p id="20240124005414-ornfouo" updated="20240124005414">Java EE（Java Platform Enterprise Edition，Java 平台企业版）以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（Service Oriented Architecture，SOA）和 Web 2.0 应用程序。</p>
<ol id="20240124005414-smgxh5s" updated="20240124005414">
<li id="20240124005414-nyhodsg" updated="20240124005414">
<p id="20240124005414-0cmz5w8" updated="20240124005414">Java ME</p>
</li>
</ol>
<p id="20240124005414-f1kx0j3" updated="20240124005414">Java ME（Java Platform Micro Edition，Java 平台微型版）以前称为 J2ME，也叫 K-JAVA。 Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。</p>
<p id="20240124005414-w0yv56y" updated="20240124005414">Java ME 包括灵活的用户界面、健壮的安全模型、丰富的内置网络协议以及对可以动态下载的联网和离线应用程序。基于 Java ME 规范的应用程序 只需编写一次就可以用于许多设备，而且可以利用每个设备的本机功能。</p>
<p id="20240124005414-fplij0q" updated="20240124005414">显示文件扩展名</p>
<p id="20240124005414-cc9lmc2" updated="20240124005414"><span class="img"><img src="assets/image_CJd4-AmLOQ-20240121141758-2v99jl9.png" alt="image_CJd4-AmLOQ.png" /></span></p>
<h2 id="20240124005414-dwkwx1r" updated="20240124005414">编程阶段</h2>
<h4 id="20240124005414-y9cbuuk" updated="20240124005414">创建包</h4>
<blockquote id="20240124005414-2fptdlu" updated="20240124005414">
<p id="20240124005414-h1t057a" updated="20240124005414">创建包的目的是为了方便管理整个工程，包的名字需要独一无二</p>
</blockquote>
<p id="20240124005414-qwyoj3l" updated="20240124005414">通用规范</p>
<blockquote id="20240124005414-lihcxbc" updated="20240124005414">
<p id="20240124005414-5yxg4u9" updated="20240124005414">此后变成建议遵循阿里的开发手册，让自己编码更好的与别人协同</p>
</blockquote>
<p id="20240124005414-n7mx891" updated="20240124005414"><a href="assets/e9af0d4111234bfda5813c72a368a168_KgPBTXkd4A-20240121141758-a94j7f7.pdf">e9af0d4111234bfda5813c72a368a168_KgPBTXkd4A.pdf</a></p>
<ul id="20240124005414-aa0ktfa" updated="20240124005414">
<li id="20240124005414-y0cxoei" updated="20240124005414">
<p id="20240124005414-put5lxv" updated="20240124005414">包名所有字母一律小写。例如：cn.lina%.chapter1..demo01。</p>
</li>
<li id="20240124005414-v4xfuvw" updated="20240124005414">
<p id="20240124005414-k1pfkai" updated="20240124005414">类名和接口名每个单词的首字母都要大写。例如：ArrayList、Iterator。</p>
</li>
<li id="20240124005414-qxmjuih" updated="20240124005414">
<p id="20240124005414-srvpnl1" updated="20240124005414">常量名所有字母都大写，单词之间用下划线连接。例如：DAY_OF_MONTH。</p>
</li>
<li id="20240124005414-sjz49js" updated="20240124005414">
<p id="20240124005414-uz2jyc1" updated="20240124005414">变量名和方法名的第一个单词首字母小写，从第二个单词开始每个单词首字母大写。例如：lineNumber、getLineNumber。</p>
</li>
</ul>
<p id="20240124005414-ujakxti" updated="20240124005414">⑤在程序中，应该尽量使用有意义的英文单词来定义标识符，使得程序便于阅<br />
读。例如：使用userName表示用户名，password表示密码。</p>
<h3 id="20240124005414-4edbc5k" updated="20240124005414">JAVA层级</h3>
<p id="20240124005414-yfw8wum" updated="20240124005414">包&gt;类&gt;方法</p>
<pre class="code-block" data-language="Java"><code class="hljs">package cn.hui7.top;

public class autochange {
    public static void main(String[] args) {

    }
}
</code></pre>
<h3 id="20240124005414-u43x017" updated="20240124005414">初识java代码</h3>
<blockquote id="20240124005414-5gsgvbm" updated="20240124005414">
<p id="20240124005414-4mpyck4" updated="20240124005414">public 是公共，可以使用以下权限。</p>
</blockquote>
<p id="20240124005414-3190f1q" updated="20240124005414">static  是静态，将该方法加入静态区</p>
<p id="20240124005414-5m5izjo" updated="20240124005414">void是无返回值</p>
<p id="20240124005414-5snc9jb" updated="20240124005414">String[] args  main()方法中的字符串数组类型的参数就是java命令的参数，使用java命令的方式运行main()方法，会将java命令的参数入参到Java main()方法的字符串数组参数中。</p>
<p id="20240124005414-effb09t" updated="20240124005414">可以使用命令  java hello asd a s d   自定义一些参数</p>
<pre class="code-block" data-language="Java"><code class="hljs">
//访问修饰符 定义为类 类名
public class asdas {
//  访问修饰符 静态 返回值 主函数入口 （字符串命令）
    public static void main(String[] args) {

    }
}

</code></pre>
<p id="20240124005414-hecu5ob" updated="20240124005414"><span class="img"><img src="assets/image_MJyZXGokYL-20240121141758-lgci5bi.png" alt="image_MJyZXGokYL.png" /></span></p>
<p id="20240124005414-26iahsx" updated="20240124005414"><span class="img"><img src="assets/image_F8T-yomjO--20240121141758-v2zz1ko.png" alt="image_F8T-yomjO-.png" /></span></p>
<h3 id="20240124005414-f0jxehu" updated="20240124005414">访问控制级别</h3>
<ul id="20240124005414-86fg0vl" updated="20240124005414">
<li id="20240124005414-usbover" updated="20240124005414">
<p id="20240124005414-iqnfa7l" updated="20240124005414">private 当前类访问级别</p>
</li>
<li id="20240124005414-6bhxs6e" updated="20240124005414">
<p id="20240124005414-gokcedy" updated="20240124005414">default 包访问级</p>
</li>
<li id="20240124005414-sin0ehy" updated="20240124005414">
<p id="20240124005414-y5jz1ne" updated="20240124005414">protected 子类访问级别</p>
</li>
<li id="20240124005414-ro6nqoi" updated="20240124005414">
<p id="20240124005414-fs2lkgg" updated="20240124005414">publice  公共访问级别</p>
</li>
</ul>
<h3 id="20240124005414-q7d65vl" updated="20240124005414">数据类型</h3>
<p id="20240124005414-kz3t2j8" updated="20240124005414">基本数据类型一共有八种，其余类型都是引用类型，每个类型都有默认值，可以声明不赋值然后输出进行查看。</p>
<p id="20240124005414-3dmflf8" updated="20240124005414">赋值时 “ ” 和 null是不一样。</p>
<p id="20240124005414-2aj7hxj" updated="20240124005414"><span class="img"><img src="assets/image_EH8lawT0Ef-20240121141758-cu1n2uv.png" alt="image_EH8lawT0Ef.png" /></span></p>
<p id="20240124005414-7eli6fw" updated="20240124005414"><span class="img"><img src="assets/image_q8JY5hB51r-20240121141758-28lxilo.png" alt="image_q8JY5hB51r.png" /></span></p>
<h4 id="20240124005414-ntv1ct3" updated="20240124005414">整型</h4>
<blockquote id="20240124005414-fm8dnna" updated="20240124005414">
<p id="20240124005414-g56w6hy" updated="20240124005414">可与long 连用让int存储的数值更多</p>
</blockquote>
<ul id="20240124005414-3brjpr9" updated="20240124005414">
<li id="20240124005414-c20yi64" updated="20240124005414">
<p id="20240124005414-ex3b5de" updated="20240124005414">L表示整型</p>
</li>
<li id="20240124005414-zs0kbw9" updated="20240124005414">
<p id="20240124005414-57gmr7l" updated="20240124005414">F表示浮点型</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">int a=10

  long a=10L; 
  float b=13.6F;

</code></pre>
<h4 id="20240124005414-95ogdrn" updated="20240124005414">浮点型</h4>
<blockquote id="20240124005414-icn6cxi" updated="20240124005414">
<p id="20240124005414-v8cq5lj" updated="20240124005414">一般使用IEEE754 标准 ，S E M 三部分构成浮点数，单双精度区别在于EM 长度</p>
</blockquote>
<ul id="20240124005414-nkpg9ll" updated="20240124005414">
<li id="20240124005414-w9036l3" updated="20240124005414">
<p id="20240124005414-p4ciqaz" updated="20240124005414">单精度 float</p>
</li>
<li id="20240124005414-8b8u82n" updated="20240124005414">
<p id="20240124005414-fhku8u5" updated="20240124005414">双精度double</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">
</code></pre>
<p id="20240124005414-aadtqqp" updated="20240124005414">字符型</p>
<h4 id="20240124005414-nn7z1el" updated="20240124005414">布尔类型：</h4>
<p id="20240124005414-jche01u" updated="20240124005414">布尔型适于逻辑运算，只有true和false两个值，一般用于程序流程控制。<br />
boolean类型占几个字节没有给出精确的定义，取决于虚拟机的实现。</p>
<h3 id="20240124005414-yycf2t7" updated="20240124005414">引用数据类型</h3>
<h3 id="20240124005414-142r6ff" updated="20240124005414">变量</h3>
<blockquote id="20240124005414-dj4o97d" updated="20240124005414">
<p id="20240124005414-ws49q8v" updated="20240124005414">变量是内存单元，定义的标识符就是变量名，内存中的值就是变量的值</p>
</blockquote>
<p id="20240124005414-0j7mkqf" updated="20240124005414">编程中的定义</p>
<pre class="code-block" data-language="Java"><code class="hljs">int a=6
</code></pre>
<h4 id="20240124005414-8vq1sn1" updated="20240124005414">常量的定义</h4>
<blockquote id="20240124005414-vr3ig07" updated="20240124005414">
<p id="20240124005414-0c5qu2f" updated="20240124005414">Java中的符号常量是由final关键字修饰的变量，final关键字决定了该变量<br />
只能被赋值一次。</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">[修饰符]final数据类型常量名[=字面值常量]；
</code></pre>
<blockquote id="20240124005414-p9jpfng" updated="20240124005414">
<p id="20240124005414-mtsp68a" updated="20240124005414">加public修饰符，这个包内都可以访问到该常量，static是加入到静态区</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">final double PI=3.14564
public static final double PI=3.14456;

</code></pre>
<p id="20240124005414-vhz3tff" updated="20240124005414">注意：</p>
<h4 id="20240124005414-26j3e0v" updated="20240124005414">基本数据类型所占用的空间</h4>
<p id="20240124005414-um2iz6z" updated="20240124005414"><span class="img"><img src="assets/image_EvhiEokDs8-20240121141758-deeel5o.png" alt="image_EvhiEokDs8.png" /></span></p>
<h3 id="20240124005414-j3dlrg8" updated="20240124005414">成员变量</h3>
<ul id="20240124005414-7cmqr5h" updated="20240124005414">
<li id="20240124005414-tv1hrjh" updated="20240124005414">
<p id="20240124005414-vmymmgz" updated="20240124005414"><span data-type="strong">成员变量又分为：实例变量和类变量。</span></p>
</li>
</ul>
<p id="20240124005414-otaydz1" updated="20240124005414">类变量也叫静态变量，即在变量前加static 的变量；</p>
<p id="20240124005414-rof7ond" updated="20240124005414">实例变量也叫对象变量，即没加static 的变量；</p>
<p id="20240124005414-kf410qk" updated="20240124005414">区别在于：类变量是所有对象共有，其中一个对象将它值改变，其他对象得到的就是改变后的结果；</p>
<p id="20240124005414-4xa4xt2" updated="20240124005414">而实例变量则为对象私有，某一个对象将其值改变，不影响其他对象；示例：</p>
<p id="20240124005414-06jwiu8" updated="20240124005414">ring toString() {<br />
return &quot;Name:&quot; + name + &quot;, Age:&quot; + age;<br />
}</p>
<pre class="code-block" data-language="Java"><code class="hljs">
class Person {
    String name;
    static int age;
    
public String toString() {
    return &quot;Name:&quot; + name + &quot;, Age:&quot; + age;
}
    
public static void main(String[] args) {
    Person p1 = new Person();
    p1.name = &quot;zhangsan&quot;;
    p1.age = 10;
    Person p2 = new Person();
    p2.name = &quot;lisi&quot;;
    p2.age = 12;
    System.out.println(p1);
    System.out.println(p2);
}
    /*
    Name:zhangsan, Age:12
    Name:lisi, Age:12
     */
   //若去掉age前的static，则输出结果为：
   /*
   Name:zhangsan, Age:10
   Name:lisi, Age:12
   */

}
</code></pre>
<ul id="20240124005414-hg5k39l" updated="20240124005414">
<li id="20240124005414-3wxu59s" updated="20240124005414">
<p id="20240124005414-0kan4jw" updated="20240124005414"><span data-type="strong">成员变量的存储：没有实例化的成员变量放在栈中；实例化后的对象放在堆中，栈中放的是指向堆中对象的引用地址。</span></p>
</li>
<li id="20240124005414-1sg9adi" updated="20240124005414">
<p id="20240124005414-xcbo6dc" updated="20240124005414"><span data-type="strong">成员变量在对象被创建时而存在，当对象被GC回收时消失，生存周期适中。</span></p>
</li>
<li id="20240124005414-0udcmug" updated="20240124005414">
<p id="20240124005414-07unjcb" updated="20240124005414"><span data-type="strong">成员变量作用在整个类中（静态方法除外），不能在定义的同时进行初始化，只能通过对象访问。示例：</span></p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">class Person {
    String name;
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.name = &quot;zhangsan&quot;;
        System.out.println(p1);
    }

}
</code></pre>
<h4 id="20240124005414-9lxx8zl" updated="20240124005414">局部变量</h4>
<ul id="20240124005414-vz49y55" updated="20240124005414">
<li id="20240124005414-rv7g736" updated="20240124005414">
<p id="20240124005414-y6snr9k" updated="20240124005414"><span data-type="strong">局部变量就是方法里定义的变量。</span></p>
</li>
<li id="20240124005414-7l48pry" updated="20240124005414">
<p id="20240124005414-75w3gi5" updated="20240124005414"><span data-type="strong">局部变量仅作用在局部区域中，从定义开始到大括号或者return结束，生命周期短。</span></p>
</li>
<li id="20240124005414-xx3sza9" updated="20240124005414">
<p id="20240124005414-u0n681c" updated="20240124005414"><span data-type="strong">局部变量存储：基本数据类型变量放在栈中，引用数据类型放在堆中</span></p>
</li>
<li id="20240124005414-i4owlud" updated="20240124005414">
<p id="20240124005414-d4ukzda" updated="20240124005414"><span data-type="strong">局部变量可以先定义再初始化，也可以定义的同时初始化，局部变量没有默认初始值。</span></p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">
class test{
    public static void main (String args[]) {
        int a;
        System.out.println(a);
        //错误: 可能尚未初始化变量a
    }

}
</code></pre>
<h3 id="20240124005414-apv0kaq" updated="20240124005414">数据类型转化</h3>
<h4 id="20240124005414-6iryff8" updated="20240124005414">自动类型转化</h4>
<blockquote id="20240124005414-b1af997" updated="20240124005414">
<p id="20240124005414-8umd7bf" updated="20240124005414">类型范围小的变量，可以直接赋值给类型范围大的变量。</p>
</blockquote>
<p id="20240124005414-dufbuh5" updated="20240124005414">当使用 byte short char是直接转换成int类型参与运算的。</p>
<p id="20240124005414-cxvqy6c" updated="20240124005414"><span class="img"><img src="assets/image_loRsKAtEkS-20240121141758-jac87ol.png" alt="image_loRsKAtEkS.png" /></span></p>
<pre class="code-block" data-language="Java"><code class="hljs">//当赋值给存储范围更大的变量时会自动转化a的变量类型为int 
byte a = sada;

int b =a;

byte i=50;

byte l=99;
//用int去接收这个类型才对
int cc=i+l
</code></pre>
<p id="20240124005414-1mqb4mz" updated="20240124005414"><span class="img"><img src="assets/image_bKb054cNrJ-20240121141758-pb49t2e.png" alt="image_bKb054cNrJ.png" /></span></p>
<pre class="code-block" data-language="Java"><code class="hljs">//字符转数字 ,会将a的ASCII码赋值个int 类型的变量 
char str=&quot;a&quot;;
int  zz=str;
</code></pre>
<h4 id="20240124005414-z9mur5c" updated="20240124005414">强制类型转化</h4>
<pre class="code-block" data-language="Java"><code class="hljs">//语法
新数据类型 新变量名=（原数据类型）被转变量名
</code></pre>
<blockquote id="20240124005414-bne01zc" updated="20240124005414">
<p id="20240124005414-icpxsy3" updated="20240124005414">当把存储范围更大的变量赋值给范围小的变量时，会导致丢失数据，所以会报错，可以使用强制类型转化, 丢失数据只有在原本存储的数据塞满小范围之后才会丢数据或数据错误</p>
</blockquote>
<p id="20240124005414-kgurz23" updated="20240124005414">丢失小数部分，或添加小数部分（ .0 ）</p>
<ul id="20240124005414-os5eoxb" updated="20240124005414">
<li id="20240124005414-20t6h75" updated="20240124005414">
<p id="20240124005414-a84bpqr" updated="20240124005414">浮点型 ⇌整型</p>
</li>
<li id="20240124005414-ap20ncz" updated="20240124005414">
<p id="20240124005414-ee9ctwd" updated="20240124005414">字符型 ⇌整形</p>
</li>
<li id="20240124005414-vmcqnn1" updated="20240124005414">
<p id="20240124005414-noishal" updated="20240124005414">字节型⇌整形</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">int a=20;

byte b=(byte)a;

</code></pre>
<p id="20240124005414-va90mt1" updated="20240124005414">强行转化时导致的数据与错误</p>
<blockquote id="20240124005414-e6tgnpw" updated="20240124005414">
<p id="20240124005414-wthxh5r" updated="20240124005414">在二进制中只能从后往前存储，并且第一位是符号位。所以输出结果完全错误。</p>
</blockquote>
<p id="20240124005414-1bju92p" updated="20240124005414"><span class="img"><img src="assets/image_XmGFNzvFRd-20240121141758-4w86u7o.png" alt="image_XmGFNzvFRd.png" /></span></p>
<h4 id="20240124005414-5munbf1" updated="20240124005414">变量数据类型转化</h4>
<p id="20240124005414-yjbh90x" updated="20240124005414"><span data-type="strong">隐式转化</span></p>
<p id="20240124005414-r93zni4" updated="20240124005414">一、 隐式转换也叫自动类型转换，指的是不需要调用函数，JVM自动将类型转换的一种方式。因为这种类型转换经常使用，Java语言在设计时，为了减轻开发人员的负担，都交给JVM来自动处理。</p>
<p id="20240124005414-a9tw5ge" updated="20240124005414">1)转换规则从存储范围小的类型到存储范围大的类型(只有前面的数据才能随便转换为后边的)</p>
<p id="20240124005414-98vqppz" updated="20240124005414">byte—&gt; short,char—&gt; int —&gt; long—&gt; float —&gt; double</p>
<ol start="2" id="20240124005414-4x5pvt2" updated="20240124005414">
<li id="20240124005414-x5y0gf6" updated="20240124005414">
<p id="20240124005414-rcjx4mg" updated="20240124005414">例子：</p>
</li>
</ol>
<p id="20240124005414-tt69ikr" updated="20240124005414">byte b = 2; short s = b; 首先JVM会将b的值转换为short类型，再将值赋值给s</p>
<p id="20240124005414-m3rwsa7" updated="20240124005414"><span data-type="strong">显示转换</span></p>
<p id="20240124005414-lauivtk" updated="20240124005414">显示转换也叫强制类型转换，指的是需要手动去处理才能完成的类型转换。该转换会存在精度损失。</p>
<p id="20240124005414-wr68rai" updated="20240124005414">1）转换规则从存储范围大的类型到存储范围小的类型</p>
<p id="20240124005414-wq61rwv" updated="20240124005414">double→float→long→int→short(char)→byte</p>
<p id="20240124005414-488a5bn" updated="20240124005414">2)例子：</p>
<p id="20240124005414-bai385f" updated="20240124005414">double d = 1.1; int i = (int)d;首先将d的值转换成int类型，然后赋值给变量i。需要注意的是小数强制转换为整数，采用的是“去1法”，也就是舍弃小数点后面所有数字，则以上转换出的结果是1。整数强制转换为整数时取数字的低位，例如int类型的变量转换为byte类型时，则只去int类型的低8位(也就是最后一个字节)的值。</p>
<p id="20240124005414-ml633on" updated="20240124005414">Java中支持的不同数据类型之间的自动转换，如下图所示。</p>
<p id="20240124005414-lgkz9xo" updated="20240124005414"><span class="img"><img src="assets/image_0eMKfEkcN_-20240121141758-aspjsp3.png" alt="image_0eMKfEkcN_.png" /></span></p>
<pre class="code-block" data-language="Plain"><code class="hljs">
</code></pre>
<h2 id="20240124005414-14vgs3b" updated="20240124005414">运算符</h2>
<h3 id="20240124005414-4ydiibl" updated="20240124005414">算数运算符</h3>
<blockquote id="20240124005414-qbypgpq" updated="20240124005414">
<p id="20240124005414-shfn6cf" updated="20240124005414">对变量进行基本的数据运算</p>
</blockquote>
<p id="20240124005414-u6b7obk" updated="20240124005414"><span class="img"><img src="assets/image_uv1hTCu9dz-20240121141758-xr57yyp.png" alt="image_uv1hTCu9dz.png" /></span></p>
<h4 id="20240124005414-czkinu4" updated="20240124005414">+号不仅可以做基本运算，还可以拼接字符串和变量</h4>
<pre class="code-block" data-language="Java"><code class="hljs">        int a=20;
        System.out.println(&quot;a的值是：&quot;+a);
</code></pre>
<h4 id="20240124005414-bprgwbz" updated="20240124005414">自增自减符号</h4>
<blockquote id="20240124005414-wyuyieu" updated="20240124005414">
<p id="20240124005414-avyinwb" updated="20240124005414">前自加和后自加的区别，前是执行到这行代码时就自加，后是执行完这行才自加，循环是循环完本次后才自加</p>
</blockquote>
<p id="20240124005414-etmzyr7" updated="20240124005414">●+和--既可以放在变量的后边，也可以放在变量的前边。<br />
●++、--只能操作变量，不能操作字面量的。</p>
<pre class="code-block" data-language="Java"><code class="hljs">int a=10;
a++ 
--a


</code></pre>
<p id="20240124005414-uvt425l" updated="20240124005414"><span class="img"><img src="assets/image_qA7COOuP7i-20240121141758-ts9e37c.png" alt="image_qA7COOuP7i.png" /></span></p>
<h3 id="20240124005414-jsls9n0" updated="20240124005414">赋值运算符</h3>
<pre class="code-block" data-language="Java"><code class="hljs">// = 就是复制号
int a=10;
</code></pre>
<h4 id="20240124005414-5trj8az" updated="20240124005414">扩展赋值运算符</h4>
<blockquote id="20240124005414-kv069v3" updated="20240124005414">
<p id="20240124005414-ytbsofr" updated="20240124005414">注意：扩展的赋值运算符隐含了强制类型转换。对数据进行运算往后赋值同步操作</p>
</blockquote>
<p id="20240124005414-6q9s870" updated="20240124005414"><span class="img"><img src="assets/image_ghyvMBiIiM-20240121141758-dpqz95p.png" alt="image_ghyvMBiIiM.png" /></span></p>
<pre class="code-block" data-language="Java"><code class="hljs">int a+=10；
</code></pre>
<h3 id="20240124005414-mp3a4xr" updated="20240124005414">关系运算符</h3>
<blockquote id="20240124005414-zrvsqm3" updated="20240124005414">
<p id="20240124005414-yfehlg8" updated="20240124005414">是对数据进行条件判断的符号，最终会返回一个比较的布尔结果(false,true)</p>
</blockquote>
<p id="20240124005414-oda2ust" updated="20240124005414"><span class="img"><img src="assets/image_Opd1PUFSfp-20240121141758-uvtk4ui.png" alt="image_Opd1PUFSfp.png" /></span></p>
<pre class="code-block" data-language="Java"><code class="hljs">(a==b) =&gt;false
</code></pre>
<h3 id="20240124005414-jijsvqn" updated="20240124005414">逻辑运算符</h3>
<blockquote id="20240124005414-dkdwn3i" updated="20240124005414">
<p id="20240124005414-gd3kjee" updated="20240124005414">可以把多个条件的布尔结果放在一起运算，最终返回一个布尔结果。对多个条件进行判断最终也返回布尔类型</p>
</blockquote>
<p id="20240124005414-vpwjthf" updated="20240124005414"><span class="img"><img src="assets/image_cKJiJp4M2i-20240121141758-a6qofcr.png" alt="image_cKJiJp4M2i.png" /></span></p>
<pre class="code-block" data-language="Java"><code class="hljs">(a&gt;b &amp;&amp;b&gt;c)
</code></pre>
<h3 id="20240124005414-7hlqbks" updated="20240124005414">三元运算符</h3>
<blockquote id="20240124005414-f20zm48" updated="20240124005414">
<p id="20240124005414-d1us0hu" updated="20240124005414">if语句的最简化，简短且可执行的语句有限</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">//语法
条件表达式? 值1 ：值2

当表达式为true时输出值1 false是输出值2
</code></pre>
<h3 id="20240124005414-wgzcqj9" updated="20240124005414">运算符优先级</h3>
<p id="20240124005414-6kr30w5" updated="20240124005414"><span class="img"><img src="assets/image_f-ha5zZn59-20240121141758-5rts7th.png" alt="image_f-ha5zZn59.png" /></span></p>
<blockquote id="20240124005414-nfhs6b6" updated="20240124005414">
<p id="20240124005414-mbgib42" updated="20240124005414">📌==  不能用于字符串比较，因为比较的是字符串的存储地址。字符串的特性是有一个之后后续在创建一样的也还是用原来的那个</p>
</blockquote>
<h2 id="20240124005414-oo1jxdi" updated="20240124005414">流程控制语句</h2>
<h3 id="20240124005414-b3o3122" updated="20240124005414">switch</h3>
<p id="20240124005414-sls89cb" updated="20240124005414">执行流程：<br />
①先执行表达式的值，拿着这个值去与case后的值进行匹配。<br />
②匹配哪个case的值为true就执行哪个case,遇到break就跳出switch分支。<br />
③如果case后的值都不匹配则执行default代码。</p>
<blockquote id="20240124005414-la2kst3" updated="20240124005414">
<p id="20240124005414-buc3war" updated="20240124005414">case的值是不能重复且只能是字面量（数字 字符串 等），且每个case内都要些break</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">表达式对应 值n就会执行第几个
switch(表达式)(
  case值1：
    执行代码.·；
    break;
    
  case值2：
    执行代码。，；
    break;
    
   case值n-1:
    执行代码。·，；
    break;
    
   default:
      执行代码n;
</code></pre>
<h4 id="20240124005414-5bzp5ee" updated="20240124005414">switch穿透性</h4>
<blockquote id="20240124005414-r54hd7q" updated="20240124005414">
<p id="20240124005414-3xfn1cv" updated="20240124005414">case中没有写break。出现switch穿透现象</p>
</blockquote>
<p id="20240124005414-x54fzqi" updated="20240124005414">switch穿透性能解决的问题，存在多个case分支的功能代码是一样时，可以用穿透性把流程集中到同一处处理，这样可以简化代码。</p>
<pre class="code-block" data-language="Java"><code class="hljs">      //等于 1 3 5 7 8 10 12时都会输出 12的结果，因为会一直穿透下去
        int month= 7;
        switch
        (month){
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                System.out.println(month+&quot;是31天！&quot;);
                break;
            case 2:
                System.out.println(month+&quot;月闰年为29天、非闰年为28天！&quot;);
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                System.out.println(month+&quot;是30天！&quot;);
                break;
            default:
                System.out.println(&quot;数据有误！&quot;);
        }
</code></pre>
<h2 id="20240124005414-vymzc58" updated="20240124005414">数组</h2>
<h4 id="20240124005414-4dzlkmx" updated="20240124005414">静态初始化</h4>
<blockquote id="20240124005414-0ducdop" updated="20240124005414">
<p id="20240124005414-4oposf4" updated="20240124005414">数组可存储很多同类型的数据</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">//声明数组的方式很多，推荐使用这一种
int[] arr={1,56,45}
</code></pre>
<h4 id="20240124005414-mvlce8b" updated="20240124005414">动态初始化</h4>
<blockquote id="20240124005414-557ul02" updated="20240124005414">
<p id="20240124005414-ad8o788" updated="20240124005414">开始不确定数组内容，后面再加入</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">int[] a=new int[10] 
</code></pre>
<p id="20240124005414-8vbbytf" updated="20240124005414">赋值给另一个数组时，赋的是地址</p>
<pre class="code-block" data-language="Java"><code class="hljs">int[] brr=arr
</code></pre>
<p id="20240124005414-zpklj0l" updated="20240124005414">访问索引值大于数组元素时出现ArrayIndexOutofBoundsException异常</p>
<pre class="code-block" data-language="Java"><code class="hljs">int[] arr={1,56,45}

arr[6] //会报错了
</code></pre>
<p id="20240124005414-iuqjbce" updated="20240124005414">赋值为null时</p>
<pre class="code-block" data-language="Java"><code class="hljs">int[] arr=null;
 //会导致栈内存的地址为null 
 //访问元素时会报错

</code></pre>
<h3 id="20240124005414-rhr8mlx" updated="20240124005414">二维数组</h3>
<pre class="code-block" data-language="Java"><code class="hljs">        //静态初始化
        int[][] a={{1,2,3,4},{4,5,6,7},{8,9,10,11}};
        //动态初始化
        String[][] b=new String[10][10];
        b[0]=new String[]{&quot;zahngsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;};
        b[1]=new String[]{&quot;java&quot;,&quot;python&quot;,&quot;c++&quot;};
</code></pre>
<h2 id="20240124005414-v3w4ajr" updated="20240124005414">JAVA内存分配</h2>
<ul id="20240124005414-ubpyw4y" updated="20240124005414">
<li id="20240124005414-2zy3k2s" updated="20240124005414">
<p id="20240124005414-h5dun9n" updated="20240124005414">方法区</p>
</li>
</ul>
<blockquote id="20240124005414-h1ljrwk" updated="20240124005414">
<p id="20240124005414-fw1ktti" updated="20240124005414">字节码文件加载时进入的内存</p>
</blockquote>
<p id="20240124005414-eoaioeu" updated="20240124005414"><span class="img"><img src="assets/image_8WxwBoVnao-20240121141758-tzdu4fz.png" alt="image_8WxwBoVnao.png" /></span></p>
<ul id="20240124005414-f2ou046" updated="20240124005414">
<li id="20240124005414-vir476n" updated="20240124005414">
<p id="20240124005414-wivjby8" updated="20240124005414">栈</p>
</li>
</ul>
<p id="20240124005414-sh7zp6t" updated="20240124005414"><span class="img"><img src="assets/image_F_Ac3CV8Dt-20240121141758-z5xi70b.png" alt="image_F_Ac3CV8Dt.png" /></span></p>
<ul id="20240124005414-zujcz98" updated="20240124005414">
<li id="20240124005414-kbv1lut" updated="20240124005414">
<p id="20240124005414-weqbxom" updated="20240124005414">堆</p>
</li>
</ul>
<p id="20240124005414-0np9f5r" updated="20240124005414"><span class="img"><img src="assets/image_Rle2_JibTs-20240121141758-57wm9i0.png" alt="image_Rle2_JibTs.png" /></span></p>
<p id="20240124005414-86m3fd3" updated="20240124005414">引用数据类型的指向，栈中只开辟一个存储地址的空间，元素实际会存在堆内存中</p>
<p id="20240124005414-sau7je8" updated="20240124005414"><span class="img"><img src="assets/image_HOZAchXDSJ-20240121141758-kh0mv1a.png" alt="image_HOZAchXDSJ.png" /></span></p>
<ul id="20240124005414-i900ggj" updated="20240124005414">
<li id="20240124005414-8wwfiny" updated="20240124005414">
<p id="20240124005414-nmaqylp" updated="20240124005414">本地方法栈</p>
</li>
<li id="20240124005414-ettk5j6" updated="20240124005414">
<p id="20240124005414-vgthtxs" updated="20240124005414">寄存器</p>
</li>
</ul>
<h3 id="20240124005414-e5x1qrq" updated="20240124005414">方法</h3>
<blockquote id="20240124005414-4febrix" updated="20240124005414">
<p id="20240124005414-dnfrwmf" updated="20240124005414">作用是提高代码复用性和模块化代码结构方便维护。 方法是在类里面 的</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">   public static void main(String[] args) {
        //当需要使用时可直接调用避免了重复写
        int xu=sum(10,6);
        System.out.println(xu);
        //调用格式 方法名（参数）
        int zhang=sum(7,6);
        System.out.println(zhang);
    }
     //当不同的地方需要使用到同一段代码操作，可以抽离出来作为一个方法
    public static int sum(int a ,int b){
        return a+b;
    }
</code></pre>
<h3 id="20240124005414-u52x3s7" updated="20240124005414">方法调用</h3>
<blockquote id="20240124005414-fmagola" updated="20240124005414">
<p id="20240124005414-98mgg44" updated="20240124005414">方法不调用就不会执行</p>
</blockquote>
<ul id="20240124005414-mq6vz8m" updated="20240124005414">
<li id="20240124005414-hly1ei0" updated="20240124005414">
<p id="20240124005414-mmkq3h9" updated="20240124005414">赋值调用</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">//将放回置赋值给一个变量
int a=sum()
</code></pre>
<ul id="20240124005414-7zp4jqq" updated="20240124005414">
<li id="20240124005414-xztg4af" updated="20240124005414">
<p id="20240124005414-mrtvr37" updated="20240124005414">输出调用</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">  System.out.println(sum());
</code></pre>
<ul id="20240124005414-tvfd6ux" updated="20240124005414">
<li id="20240124005414-dw7fpo2" updated="20240124005414">
<p id="20240124005414-l1g8bbf" updated="20240124005414">直接调用 +无返回值的调用</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">//返回值不要了
sum()

</code></pre>
<h4 id="20240124005414-zjsxvqj" updated="20240124005414">方法调用在内存中的流程</h4>
<ol id="20240124005414-lysy9fe" updated="20240124005414">
<li id="20240124005414-qt1ve2s" updated="20240124005414">
<p id="20240124005414-3sqys8x" updated="20240124005414">将java文件加载到方法去</p>
</li>
<li id="20240124005414-vng9n09" updated="20240124005414">
<p id="20240124005414-wu6si6v" updated="20240124005414">将main放入栈区中执行，其他方法和基本数据类型的赋值也是在这里</p>
</li>
<li id="20240124005414-aof34s8" updated="20240124005414">
<p id="20240124005414-xu7af9g" updated="20240124005414">方法使用完之后会自动释放</p>
</li>
</ol>
<p id="20240124005414-ou9hkhf" updated="20240124005414"><span class="img"><img src="assets/image_i3JiGr88tg-20240121141758-uwgyp2z.png" alt="image_i3JiGr88tg.png" /></span></p>
<h4 id="20240124005414-v2u20d3" updated="20240124005414">方法中值的传递，参数（形参，实参）</h4>
<blockquote id="20240124005414-4nb9eht" updated="20240124005414">
<p id="20240124005414-al8x4el" updated="20240124005414">方法名（参数值，参数值2）  实参的个数和形参的个数相同  ，调用的时候写的是实参，接收的方法叫形参</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">   public static void main(String[] args) {
                  //实参
        int xu=sum(10,6);
        System.out.println(xu);
    }
                        //形参
    public static int sum(int a ,int b){
        return a+b;
    }
</code></pre>
<blockquote id="20240124005414-kjtr871" updated="20240124005414">
<p id="20240124005414-fhag8kj" updated="20240124005414">传递的内容：  变量  常量  方法  引用数据变量 等</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">int[] arr={41,456,4}
//此时传递的是地址
sum(arr)
</code></pre>
<h3 id="20240124005414-6hwfo1y" updated="20240124005414">方法重载</h3>
<blockquote id="20240124005414-b318ysw" updated="20240124005414">
<p id="20240124005414-t5sxju3" updated="20240124005414">同一个类中，出现多个方法名称相同，但是形参列表是不同的，那么这些方法就是重载方法。</p>
</blockquote>
<p id="20240124005414-yoqj38a" updated="20240124005414">作用就是可读性好 ，方法名称相同提示是同一类型的功能，通过形参不同实现功能差异化的选择，</p>
<p id="20240124005414-gsk1b3f" updated="20240124005414">参数列表： 个数  数据类型  参数顺序   public 有无都可</p>
<p id="20240124005414-jmnuyzb" updated="20240124005414">优化写法可以省略代码量，只需要指定某些默认值即可，重写+嵌套</p>
<pre class="code-block" data-language="Java"><code class="hljs">    public static void main(String[] args) {
    fire(&quot;riben&quot;,5);
    }
    public static void fire() {
       // System.out.println(&quot;默认发射一枚武器给xxx国ww~&quot;);
       //优化写法
       fire(&quot;xxx国&quot;)
       return 
    }
    public static void fire(String country) {
       // System.out.println(&quot;默认发射一枚武器给&quot;+country+&quot;国ww~&quot;);
       //优化写法
       fire(country,1)
    }
    public static void fire(String country,int number) {
        System.out.println(&quot;发射&quot;+number+&quot;枚武器给&quot;+country+&quot;国ww~&quot;);
    }
</code></pre>
<blockquote id="20240124005414-i7ro1s2" updated="20240124005414">
<p id="20240124005414-oe6jvoc" updated="20240124005414">return可以在无返回值的方法中使用。即结束当前的方法</p>
</blockquote>
<h3 id="20240124005414-liqqtai" updated="20240124005414">引用变量类型</h3>
<blockquote id="20240124005414-wen3mkb" updated="20240124005414">
<p id="20240124005414-rxbdnbe" updated="20240124005414">引用变量类型的本意就是引用的只是一个地址，实际的值存在堆中，而栈中只有一个地址并指向堆。</p>
</blockquote>
<p id="20240124005414-zcwmo19" updated="20240124005414">数据类型：</p>
<ul id="20240124005414-lhdeyjn" updated="20240124005414">
<li id="20240124005414-prt0e63" updated="20240124005414">
<p id="20240124005414-8eupbqj" updated="20240124005414">基本数据类型</p>
</li>
</ul>
<p id="20240124005414-x09i5cr" updated="20240124005414">包括：btye  short int long  float double  booler char</p>
<ul id="20240124005414-2i50pm5" updated="20240124005414">
<li id="20240124005414-dtdwqoq" updated="20240124005414">
<p id="20240124005414-5ztwgvs" updated="20240124005414">复杂数据类型（引用变量类型）</p>
</li>
</ul>
<p id="20240124005414-b7qsltb" updated="20240124005414">包括：对象</p>
<pre class="code-block" data-language="Java"><code class="hljs">  //操作是将类实例化成具体对象 ，而这个对象的数据类型是引用变量类型
  duixang c1=new duixang();
</code></pre>
<h2 id="20240124005414-2mthzju" updated="20240124005414">面向对象式编程OOP</h2>
<blockquote id="20240124005414-r40dc62" updated="20240124005414">
<p id="20240124005414-575p0nz" updated="20240124005414">以类为主题单位，一个类就是一个对象，类的设计包含以下部分</p>
</blockquote>
<p id="20240124005414-3p7gfg1" updated="20240124005414">面向对象的三大特征：封装，继承，多态。</p>
<blockquote id="20240124005414-dqj3amy" updated="20240124005414">
<p id="20240124005414-4dg030m" updated="20240124005414">在实际编程中，一个java文件可以包含多个类，但实际开发时一个文件只放一个类</p>
</blockquote>
<h3 id="20240124005414-j2crb1e" updated="20240124005414">类</h3>
<blockquote id="20240124005414-1tbj45t" updated="20240124005414">
<p id="20240124005414-6qhl6kz" updated="20240124005414">相同事物共同特征的描述 ，如人类</p>
</blockquote>
<blockquote id="20240124005414-owq7zi6" updated="20240124005414">
<p id="20240124005414-uey1nqk" updated="20240124005414">类的声明包含一下几点</p>
</blockquote>
<ul id="20240124005414-no6vyct" updated="20240124005414">
<li id="20240124005414-bzzatt8" updated="20240124005414">
<p id="20240124005414-oj6hkr4" updated="20240124005414">访问权限</p>
</li>
<li id="20240124005414-grsxafm" updated="20240124005414">
<p id="20240124005414-moz9z9c" updated="20240124005414">返回值类型</p>
</li>
<li id="20240124005414-l0dg7bn" updated="20240124005414">
<p id="20240124005414-2rwws40" updated="20240124005414">是否静态</p>
</li>
<li id="20240124005414-3w477yq" updated="20240124005414">
<p id="20240124005414-tsbis5w" updated="20240124005414">类名</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs"> public class human{
 }
</code></pre>
<h4 id="20240124005414-brsjc5u" updated="20240124005414">类的结构体设计</h4>
<blockquote id="20240124005414-sx252b2" updated="20240124005414">
<p id="20240124005414-4g9qcf0" updated="20240124005414">类只是一个抽象的集合 例如学生有  姓名 年龄 学号等 ，这就是一个类，但要具体到某个学生的信息时，就要把类给具体化，实例化出来。</p>
</blockquote>
<ol id="20240124005414-w59j7e6" updated="20240124005414">
<li id="20240124005414-4lnutdl" updated="20240124005414">
<p id="20240124005414-ffsmhv5" updated="20240124005414">成员方法（方法）</p>
</li>
<li id="20240124005414-39ux197" updated="20240124005414">
<p id="20240124005414-etcu7vl" updated="20240124005414">成员变量（属性）</p>
</li>
<li id="20240124005414-ohk1rwe" updated="20240124005414">
<p id="20240124005414-0ty04rn" updated="20240124005414">构造器（与类名相同的方法）</p>
</li>
<li id="20240124005414-e02fxy4" updated="20240124005414">
<p id="20240124005414-bb5w85x" updated="20240124005414">代码块（  { }   ）</p>
</li>
<li id="20240124005414-xou1v6b" updated="20240124005414">
<p id="20240124005414-qpq1lmv" updated="20240124005414">内部类</p>
</li>
</ol>
<blockquote id="20240124005414-yg582eu" updated="20240124005414">
<p id="20240124005414-jedd7b0" updated="20240124005414">📌类名首字母建议大写，有意义，满足驼峰，不<br />
要用关键字，合法的标志符</p>
</blockquote>
<blockquote id="20240124005414-n7rvr8p" updated="20240124005414">
<p id="20240124005414-9kjz5aw" updated="20240124005414">📌一个Java文件中可以定义多个类，但是只能<br />
一个类是poublic修饰的，而且public修饰的类名<br />
必须成为java代码的文件名称，否则报错！</p>
</blockquote>
<h4 id="20240124005414-0fgs1ej" updated="20240124005414">成员方法</h4>
<pre class="code-block" data-language="Java"><code class="hljs">    //类
    public class duixang{
    // 成员变量 代表对象的属性 一般是名词
         int age;
        String name;
    
    //- 成员方法 代表对象的功能行为，一般是动词
        public int getAge() {
            return age;
            }
        - 构造器
        - 代码块
        - 内部类
    }
</code></pre>
<h4 id="20240124005414-hgiawxj" updated="20240124005414">成员变量</h4>
<blockquote id="20240124005414-0ozt59z" updated="20240124005414">
<p id="20240124005414-hyzm4k6" updated="20240124005414">成员变量分为两种：静态变量和实例化成员变量</p>
</blockquote>
<blockquote id="20240124005414-tpr6egh" updated="20240124005414">
<p id="20240124005414-5finbhf" updated="20240124005414">成员变量和局部变量的区别：</p>
</blockquote>
<p id="20240124005414-afagjxn" updated="20240124005414"><span class="img"><img src="assets/image_GS4xt282CB-20240121141758-ujwxsja.png" alt="image_GS4xt282CB.png" /></span></p>
<p id="20240124005414-i0yaw5p" updated="20240124005414"><span class="img"><img src="assets/image_xS0ILCvmfT-20240121141758-wd6x0j3.png" alt="image_xS0ILCvmfT.png" /></span></p>
<p id="20240124005414-63a6238" updated="20240124005414">成员变量的两种类型</p>
<ul id="20240124005414-dmnqyb1" updated="20240124005414">
<li id="20240124005414-szbrzy7" updated="20240124005414">
<p id="20240124005414-19mdk7v" updated="20240124005414">静态</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">    static int classcount = 39;
    //可以直接调用
      System.out.println(&quot;男孩数量&quot;+
      boys);
</code></pre>
<ul id="20240124005414-ecduamx" updated="20240124005414">
<li id="20240124005414-g5c7s4x" updated="20240124005414">
<p id="20240124005414-xkmbesj" updated="20240124005414">实例</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">        //实例化构造方法类，然后通过调用类的属性实现。
         information s=new information();   
         System.out.println(&quot;男孩数量&quot;+s.boys);

</code></pre>
<p id="20240124005414-bql7kkd" updated="20240124005414">成员方法</p>
<ul id="20240124005414-26joli4" updated="20240124005414">
<li id="20240124005414-bfxnbxb" updated="20240124005414">
<p id="20240124005414-4703gun" updated="20240124005414">构造方法（构造器） 没有返回值，与类的名字是相同的</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">    //   构造方法
    public information(int classcount, int boys, int girls) {
        super();
        this.classcount = classcount;
        this.boys = boys;
        this.girls = girls;
    }

    public information() {
        super();
    }


//引用时需要实例化对象才可以引用对象内的成员
</code></pre>
<ul id="20240124005414-9noqfcf" updated="20240124005414">
<li id="20240124005414-ev0tmjm" updated="20240124005414">
<p id="20240124005414-tm22niw" updated="20240124005414">普通方法（方法1.2.3.4）可选返回值，</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">public static void main(String[])
</code></pre>
<p id="20240124005414-z52vi9q" updated="20240124005414">构造方法和普通方法的区别：构造方法名和类一致，不需要说明返回值。</p>
<h4 id="20240124005414-sfdyigl" updated="20240124005414">构造器</h4>
<blockquote id="20240124005414-2y2j5p4" updated="20240124005414">
<p id="20240124005414-svbh08v" updated="20240124005414">定义在类中的，可以用于初始化一个类的对象，并返回对象的地址。</p>
</blockquote>
<ul id="20240124005414-5wqi3em" updated="20240124005414">
<li id="20240124005414-3c77j17" updated="20240124005414">
<p id="20240124005414-1xu5ja0" updated="20240124005414">无参数构造器（默认存在的）：初始化对象时，成员变量的数据均采用默认值。</p>
</li>
<li id="20240124005414-use88o8" updated="20240124005414">
<p id="20240124005414-vskrczz" updated="20240124005414">有参数构造器：在初始化对象的时候，同时可以接收参数为对象进行赋值。定义有参后如果还需要调用无参就需要额外定义无参</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">//
duixiang obj=new Car()

public class Car{

//无参数构造器，作用就是返回这个初始对象，和返回地址，即使没写也会自动加上
      public Car(){

    }
//有参数构造器，可在实例化的同时也传递参数
    public Car( int a){

     }

}


</code></pre>
<h3 id="20240124005414-v9w17wx" updated="20240124005414">代码块</h3>
<blockquote id="20240124005414-yh8lw0d" updated="20240124005414">
<p id="20240124005414-2dv85fn" updated="20240124005414">在)ava类下，使用()括起来的代码被称为代码块。定义在类中方法之外</p>
</blockquote>
<p id="20240124005414-qn4yc73" updated="20240124005414">分为静态代码块和构造代码块</p>
<h4 id="20240124005414-zn4ibyz" updated="20240124005414">静态代码块</h4>
<ul id="20240124005414-dn5xsn8" updated="20240124005414">
<li id="20240124005414-yzc1ege" updated="20240124005414">
<p id="20240124005414-9tmnvaz" updated="20240124005414">格式：static{}</p>
</li>
<li id="20240124005414-ivh7bod" updated="20240124005414">
<p id="20240124005414-0i7h8a7" updated="20240124005414">特点：需要通过static关键字修饰，会随着类的加载而加载，并会自动触发，只执行一次</p>
</li>
<li id="20240124005414-7ohb6d2" updated="20240124005414">
<p id="20240124005414-z3qsu3d" updated="20240124005414">使用场景：在加载类的时候做一些静态初始化的操作</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">  public  static int z;
    static {
        z=6;
    }
</code></pre>
<h4 id="20240124005414-r80ki7c" updated="20240124005414">构造代码块（仅了解）</h4>
<ul id="20240124005414-eo3zmx4" updated="20240124005414">
<li id="20240124005414-rmovn7a" updated="20240124005414">
<p id="20240124005414-u6mub94" updated="20240124005414">格式：{}</p>
</li>
<li id="20240124005414-5qnnnm1" updated="20240124005414">
<p id="20240124005414-a3j47a2" updated="20240124005414">特点:每次创建对象，调用构造器时都会执行这个代码块中的代码，并且在构造器之前执行</p>
</li>
<li id="20240124005414-q3a38s7" updated="20240124005414">
<p id="20240124005414-25j1t8o" updated="20240124005414">初始化实例资源</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">  public  static int z;
    static {
        z=6;
    }
</code></pre>
<h3 id="20240124005414-btb1ymd" updated="20240124005414">this</h3>
<blockquote id="20240124005414-om3779q" updated="20240124005414">
<p id="20240124005414-0ehxxn8" updated="20240124005414">可以用于指定访问当前对象的成员变量、成员方法。</p>
</blockquote>
<ul id="20240124005414-4dr3xlz" updated="20240124005414">
<li id="20240124005414-qeiy224" updated="20240124005414">
<p id="20240124005414-bs2w28k" updated="20240124005414">可以出现在构造器、方法中</p>
</li>
<li id="20240124005414-08sxal8" updated="20240124005414">
<p id="20240124005414-uk9x8em" updated="20240124005414">代表当前对象的地址。</p>
</li>
</ul>
<p id="20240124005414-sqin938" updated="20240124005414">局部的变量和方法名本身是没有意义的只是为了传参，但是重新命名有过于麻烦，并且局部和全局冲突的时候难以指定，this指向的是成员（全局）的变量，age指向的是当前方法的局部变量</p>
<pre class="code-block" data-language="Java"><code class="hljs">    public static class duixang{
        int age ;
        String name;
        public void car(int age ,String name){
        this.age=age;
        this.name=name;
        }
    }
</code></pre>
<h3 id="20240124005414-s8crmpw" updated="20240124005414">封装</h3>
<blockquote id="20240124005414-up9qwqw" updated="20240124005414">
<p id="20240124005414-nf6d1sy" updated="20240124005414">封装告诉我们，如何正确设计对象的属性和方法。</p>
</blockquote>
<p id="20240124005414-1jy7t1q" updated="20240124005414">将常用的代码封装起来方便以后调用可以不用多次重复写</p>
<p id="20240124005414-l3u34lu" updated="20240124005414">封装的原则：对象代表什么，就得封装对应的数据，并提供数据对应的行为。</p>
<p id="20240124005414-7to8vms" updated="20240124005414">当几个对象相互作用的时候就难以分辨方法的归属问题。</p>
<p id="20240124005414-2who94o" updated="20240124005414">在面向对象中  ，  人画园这个操作，</p>
<p id="20240124005414-5bc1ajy" updated="20240124005414">人有属性和方法，但是画园并不是人本身的方法，而是调用了园的方法，园定义有半径等属性，根据这个属性从而形成的园，所以人是调用画圆的方法</p>
<p id="20240124005414-uxe5nol" updated="20240124005414"><span class="img"><img src="assets/image_iJkYP-WgXA-20240121141758-f8cdii3.png" alt="image_iJkYP-WgXA.png" /></span></p>
<h3 id="20240124005414-kocepl0" updated="20240124005414">封装权限</h3>
<blockquote id="20240124005414-g7n85ny" updated="20240124005414">
<p id="20240124005414-m9gqgfr" updated="20240124005414">封装时public 权限可以直接数据赋值会导致一些业务逻辑的错误</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">    public static class duixang{
        int age ;
         String name;
        public void car(int age ,String name){
        this.age=age;
        this.name=name;
        }
    }
    
    //逻辑上是错误的，没有负的年龄
    duixiang.age=-100 
    //所以不应该能直接赋值，而是通过间接的设置
    
</code></pre>
<h4 id="20240124005414-seoubto" updated="20240124005414">getter和setter</h4>
<blockquote id="20240124005414-cfpn5ix" updated="20240124005414">
<p id="20240124005414-08mga4u" updated="20240124005414">将public 改为 私有的 private ，此时的修改权限只有类的内部才可以调用</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">       private int age ;
       private  String name;
       
        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
</code></pre>
<h3 id="20240124005414-k1ujsp7" updated="20240124005414">JavaBean</h3>
<blockquote id="20240124005414-irfl4p0" updated="20240124005414">
<p id="20240124005414-hwmucg3" updated="20240124005414">也可以称为实体类，其对象可以用于在程序中封装数据。</p>
</blockquote>
<p id="20240124005414-6jeeliu" updated="20240124005414">实体类是这个类对应现实生活中真正存在的对象，比如 车类  人类  猴子类</p>
<h4 id="20240124005414-o959lwv" updated="20240124005414">标准]avaBean须满足如下书写要求：</h4>
<ul id="20240124005414-08415vd" updated="20240124005414">
<li id="20240124005414-oqqb3xg" updated="20240124005414">
<p id="20240124005414-hfxdpnw" updated="20240124005414">成员变量使用private修饰。</p>
</li>
<li id="20240124005414-usovh43" updated="20240124005414">
<p id="20240124005414-un7g845" updated="20240124005414">提供成员变量对应的setXxx0/getXxx(0方法。</p>
</li>
<li id="20240124005414-mnxxd32" updated="20240124005414">
<p id="20240124005414-vfvhv8e" updated="20240124005414">必须提供一个无参构造器；有参数构造器是可写可不写的。</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">  public static class User{
    private String name;
    private int age;

        public User() {
        }

        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }
</code></pre>
<h2 id="20240124005414-ayenwyb" updated="20240124005414">API</h2>
<blockquote id="20240124005414-62bo8k6" updated="20240124005414">
<p id="20240124005414-69g3k22" updated="20240124005414">直译 应用程序接口，简单理解就是调用已经写好的程序</p>
</blockquote>
<ul id="20240124005414-4xqvnzi" updated="20240124005414">
<li id="20240124005414-o5wfokc" updated="20240124005414">
<p id="20240124005414-ky72ltz" updated="20240124005414">导入包</p>
</li>
<li id="20240124005414-34iet3u" updated="20240124005414">
<p id="20240124005414-u4bswva" updated="20240124005414">实例化包</p>
</li>
<li id="20240124005414-54bm1ha" updated="20240124005414">
<p id="20240124005414-q14vrav" updated="20240124005414">调用实例化方法</p>
</li>
</ul>
<h4 id="20240124005414-duuqnsu" updated="20240124005414">api的简单应用</h4>
<h3 id="20240124005414-hsdbsv9" updated="20240124005414">Scanner的 简单应用</h3>
<blockquote id="20240124005414-zdjo4x2" updated="20240124005414">
<p id="20240124005414-93n9xzu" updated="20240124005414">next和nextInt的区别</p>
</blockquote>
<ul id="20240124005414-3k5fsbq" updated="20240124005414">
<li id="20240124005414-ph9vhp5" updated="20240124005414">
<p id="20240124005414-su1ufy2" updated="20240124005414">next遇到空白时停止，读取输入后将光标放在同一行中</p>
</li>
<li id="20240124005414-zo50e7o" updated="20240124005414">
<p id="20240124005414-z6clc3p" updated="20240124005414">nextInt 读取遇到回车停止，读取输入后将光标放在下一行中</p>
</li>
<li id="20240124005414-jg5avci" updated="20240124005414">
<p id="20240124005414-3bfmfvr" updated="20240124005414">nextLine 是读取字符串的</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">  import java.util.Scanner;
  
   //在idea编辑的时候直接输入Scanner 就可以自动导入
        Scanner sc=new Scanner(System.in);
        //调用功能
        System.out.println(&quot;请输入年龄&quot;);
        //Int表示接的是整数
        int age=sc.nextInt();

        System.out.println(&quot;请输入名称&quot;);
        String name=sc.next();
</code></pre>
<h3 id="20240124005414-em5h5nx" updated="20240124005414">Random() 的简单使用</h3>
<pre class="code-block" data-language="Java"><code class="hljs">        Random r= new Random();
        //生成0-10的中的整数
        int number=r.nextInt(10);
        //生成1-10的中的整数
        int number2=r.nextInt(10)+1;
        System.out.println(&quot;number:&quot;+number+&quot;----number:&quot;+number2);
</code></pre>
<h3 id="20240124005414-lxxgxrf" updated="20240124005414">ArrayList</h3>
<ul id="20240124005414-ycwzj4s" updated="20240124005414">
<li id="20240124005414-lpbi7ha" updated="20240124005414">
<p id="20240124005414-2t9p051" updated="20240124005414">ArrayList代表的是集合类，集合是一种容器，与数组类似，不同的是集合的大小是不固定的。集合非常适合做元素个数不确定，且要进行增删操作的业务场景。</p>
</li>
<li id="20240124005414-o00pwfo" updated="20240124005414">
<p id="20240124005414-vmn58ec" updated="20240124005414">通过创建ArrayList的对象表示得到一个集合容器，同时ArrayList提供了比数组更好用，更丰富的API(功能)给程序员使用。</p>
</li>
<li id="20240124005414-y571i78" updated="20240124005414">
<p id="20240124005414-pmzgzxv" updated="20240124005414">可以存储任意类型的元素，但不建议这么做</p>
</li>
</ul>
<blockquote id="20240124005414-s32bu0w" updated="20240124005414">
<p id="20240124005414-s4jys3s" updated="20240124005414">📌数组定义完成并启动后，类型确定、长度固定。在个数不能确定，且要进行增删数据操作的时候，数组是不太合适的。</p>
</blockquote>
<h4 id="20240124005414-mutwht1" updated="20240124005414">创建ArrayList集合，</h4>
<p id="20240124005414-ln3vr1q" updated="20240124005414">集合是对象</p>
<pre class="code-block" data-language="Java"><code class="hljs">ArrayList arr=new ArrayList&lt;&gt;();

//以后定义必须得定义数据类型
      ArrayList&lt;String&gt; list2=new ArrayList&lt;&gt;();
        list2.add(&quot;Sadasd&quot;);
定义数据类型后只能写这个类型的数据

//泛型，支持很多类型，但也不能乱用
  ArrayList&lt;objet&gt; list2=new ArrayList&lt;&gt;();
        list2.add(&quot;Sadasd&quot;);



</code></pre>
<h4 id="20240124005414-t4vgihh" updated="20240124005414">add添加数据</h4>
<blockquote id="20240124005414-nq26khc" updated="20240124005414">
<p id="20240124005414-r1b0fnl" updated="20240124005414">添加数据,返回值为添加结果，类型为布尔型 可指定位置</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs"> 
 //语法   插入位置，插入元素,如果不指定插入位置则参入到最后
 集合.add(index,data)
 
        arr.add(&quot;java2&quot;);
        arr.add(1,&quot;java2&quot;);
        System.out.println(arr.add(&quot;java&quot;));
</code></pre>
<h4 id="20240124005414-ns8jyqh" updated="20240124005414">get获取元素</h4>
<blockquote id="20240124005414-9luacyu" updated="20240124005414">
<p id="20240124005414-qpn7a2b" updated="20240124005414">:获取某个索引位置处的元素值</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">//1、public E get(int index)
String e= List.get(3);
System.out.println(e);
</code></pre>
<h4 id="20240124005414-xv5ic9c" updated="20240124005414">size获取集合元素个数</h4>
<pre class="code-block" data-language="Java"><code class="hljs">//2、public int size():获取集合的大小（元素个数）
 System.out.println(&quot;元素个数&quot;+list2.size());
</code></pre>
<h4 id="20240124005414-b9ygnad" updated="20240124005414">遍历集合</h4>
<pre class="code-block" data-language="Java"><code class="hljs">//3、完成集合的遍历
for (int i=0;i&lt;list.size();i++){
System.out.println(list.get(i));
}

</code></pre>
<h4 id="20240124005414-grtde40" updated="20240124005414">remove删除元素</h4>
<blockquote id="20240124005414-hczxzhl" updated="20240124005414">
<p id="20240124005414-hqbbtq6" updated="20240124005414">删除某个索引位置处的元素值，并返回被删除的元素值，也可以指定被删除元素的内容去删除，但只会删除第一个，从头往后的第一个</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">
public E remove(int index)
        list2.add(&quot;Sadasd&quot;);
        list2.add(&quot;asdasdddd&quot;);
        list2.add(&quot;asdasdddd&quot;);
        list2.add(&quot;asdasdddd&quot;);
        //list2=Sadasd，asdasdddd，asdasdddd，asdasdddd
        
        //会返回被删除的值
        list2.remove(1);
        list2.remove(&quot;asdasdddd&quot;);
        
       // list2=Sadasd asdasdddd

</code></pre>
<h4 id="20240124005414-qnv1zd4" updated="20240124005414">set修改元素</h4>
<blockquote id="20240124005414-qlrfisu" updated="20240124005414">
<p id="20240124005414-jk2oqx8" updated="20240124005414">修改某个索引位置的元素值 ，也会返回被修改的值</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">String e3=1ist1.set(0,&quot;贾乃亮&quot;)；
System.out.println(e3);
System.out.println(list1);
</code></pre>
<h2 id="20240124005414-sel4zec" updated="20240124005414">面向对象</h2>
<blockquote id="20240124005414-yx0a68p" updated="20240124005414">
<p id="20240124005414-ccpem8s" updated="20240124005414">通过构造器实例化对象时。且有继承状态下，子类的构造器中自带super方法调用父类的无参构造器。有静态代码块和无参构造器同时存在时，会先执行静态代码块</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">class test
   
</code></pre>
<h3 id="20240124005414-0e1ewi2" updated="20240124005414">类和对象的关系</h3>
<blockquote id="20240124005414-dpsmc1v" updated="20240124005414">
<p id="20240124005414-227hz39" updated="20240124005414">类是一个抽象概念，是一个大范围的东西。</p>
</blockquote>
<p id="20240124005414-wg88bpv" updated="20240124005414">对象是一个具体的东西。</p>
<p id="20240124005414-50lxp76" updated="20240124005414">类实例化之后就变成了具体的对象</p>
<p id="20240124005414-k1wla9w" updated="20240124005414">人实例化到某个具体的人，而这个具体的人可能会有自己的性格想法等，但是总体人这个类包含的对象也会包含比如眼睛鼻子耳朵</p>
<h3 id="20240124005414-65wtypp" updated="20240124005414">类</h3>
<blockquote id="20240124005414-gsmqvoz" updated="20240124005414">
<p id="20240124005414-d3f1ves" updated="20240124005414">类的抽象理解有两种方法，一种是面向对象，一种是面向过程。</p>
</blockquote>
<blockquote id="20240124005414-5imdmqg" updated="20240124005414">
<p id="20240124005414-46u9z7m" updated="20240124005414">面向对象是以方法为对象进行分离，数据以成员变量型式，函数以对象型式</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">package clas;

public class information {
    //变量要放在类下面，要不然生成的构造函数就不能选择参数
//    使用静态方法可以直接全局调用更方便
    static final int classnumber = 2102;
    static int classcount = 39;
    static   int boys = 33;
    static   int girls = 6;

    //   构造方法
    public information(int classcount, int boys, int girls) {
        super();
        this.classcount = classcount;
        this.boys = boys;
        this.girls = girls;
    }

    public information() {
        super();
    }

    public   static  void getmaxin(int boys, int girls) {
//        return boys&gt;girls?boys:girls;
        if (boys &gt; girls) {
            System.out.println(&quot;男生比女生多&quot; + &quot;男生人数&quot; + boys);
        } else {
            System.out.println(&quot;女生比较多&quot; + &quot;女生人数&quot; + girls);
        }
    }
    public   static  void getnum(int classnumber){
        if(classnumber%2==0){
            System.out.println(&quot;班级编号是偶数&quot;);
        }else{
            System.out.println(&quot;班级编号是集数&quot;);
        }
        System.out.println(&quot;班级人数&quot;+classcount+&quot;班级号&quot;+classnumber);

    }


    public static void main(String[] args) {
        //实例化类，然后通过调用类的属性实现。 information s=new information();   
        
        //  System.out.println(&quot;男孩数量&quot;+s.boys);

        System.out.println(&quot;男孩数量&quot;+boys);
        System.out.println(&quot;女孩数量&quot;+girls);
        System.out.println(&quot;人数数量&quot;+classcount);
        getmaxin(boys, girls);
        getnum(classnumber);

    }

}

</code></pre>
<p id="20240124005414-n448hq0" updated="20240124005414">面向对象有三个特性：继承性 封装性和多态性</p>
<ul id="20240124005414-0m4oaat" updated="20240124005414">
<li id="20240124005414-w92tqey" updated="20240124005414">
<p id="20240124005414-u4wbzpr" updated="20240124005414">继承是可以把父级内的所有东西结成，</p>
</li>
<li id="20240124005414-3v3dgdy" updated="20240124005414">
<p id="20240124005414-wcw5n2l" updated="20240124005414">封装性是把单独的对象封装起来成一个类方便后面复用</p>
</li>
<li id="20240124005414-m9qdmnl" updated="20240124005414">
<p id="20240124005414-82wkvrq" updated="20240124005414">多态性是指</p>
</li>
</ul>
<h3 id="20240124005414-ul6s5tz" updated="20240124005414">类的实例化→对象</h3>
<blockquote id="20240124005414-whpm24p" updated="20240124005414">
<p id="20240124005414-a9vpvmc" updated="20240124005414">类是抽象的，只有实例化之后才会给某个东西附上具体的值从而变成一个具体的对象。 例如 学生名字 xx  年龄18.....</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">//语法  ,对象名指的就是实例化之后的这个具体类的名字

类名(数据类型) 对象名 =new 构造器(可选参数)
duixiang obj=new duixang()

//可定义为数组，存储几个对象
duixiang[] obj=new duixang[3]

duixiang[]=objarr

Movie[]movies = new Movie[3];

Movie m1=new Movie〔name:&quot;《长津湖》&quot;，5core:9.7,actor:&quot;吴京&quot;)；
movies[0]=m1;


movies[0]=new Movie〔name:&quot;《长津湖》&quot;，5core:9.7,actor:&quot;吴京&quot;)；

</code></pre>
<p id="20240124005414-594rokx" updated="20240124005414"><span class="img"><img src="assets/image_eEf-m9L2qF-20240121141758-69w8h9j.png" alt="image_eEf-m9L2qF.png" /></span></p>
<h3 id="20240124005414-349iifa" updated="20240124005414">对象的调用</h3>
<blockquote id="20240124005414-92ldw0l" updated="20240124005414">
<p id="20240124005414-8dpd17p" updated="20240124005414">对象创建成功之后，可以给对象的属性赋值，获取属性值，增加等操作</p>
</blockquote>
<p id="20240124005414-wywb0ju" updated="20240124005414">对象内容存储在堆内存中</p>
<p id="20240124005414-qusgwb6" updated="20240124005414">对象本身只是一个堆的地址</p>
<pre class="code-block" data-language="Java"><code class="hljs">//调用对象的属性

//语法  对象名.属性名   对象名.方法名()
obj.name
obj.getAge()
</code></pre>
<h3 id="20240124005414-mgq5kw1" updated="20240124005414">类和对象的内存图解</h3>
<p id="20240124005414-cq3yex5" updated="20240124005414"><span class="img"><img src="assets/image_0j5LKYzSnE-20240121141758-9ydi5ax.png" alt="image_0j5LKYzSnE.png" /></span></p>
<ul id="20240124005414-reh4mqe" updated="20240124005414">
<li id="20240124005414-jed6k0o" updated="20240124005414">
<p id="20240124005414-e7remei" updated="20240124005414">对象的成员方法不会存在堆内存中，而是会放到方法区</p>
</li>
<li id="20240124005414-dav2w93" updated="20240124005414">
<p id="20240124005414-os6qdef" updated="20240124005414">对象的基本数据类型会放在堆内存中</p>
</li>
</ul>
<p id="20240124005414-kso2uc9" updated="20240124005414"><span class="img"><img src="assets/image_vVU74aOLRm-20240121141758-veyzloc.png" alt="image_vVU74aOLRm.png" /></span></p>
<ul id="20240124005414-jh5jdwp" updated="20240124005414">
<li id="20240124005414-urcsjhh" updated="20240124005414">
<p id="20240124005414-wsntgak" updated="20240124005414">static关键字</p>
</li>
<li id="20240124005414-9o2wrvp" updated="20240124005414">
<p id="20240124005414-gce0ik4" updated="20240124005414">设计模式</p>
</li>
<li id="20240124005414-0dvbqlp" updated="20240124005414">
<p id="20240124005414-ilf6u3g" updated="20240124005414">继承</p>
</li>
</ul>
<h3 id="20240124005414-o2s919r" updated="20240124005414">static静态</h3>
<p id="20240124005414-e6symiw" updated="20240124005414">●static是静态的意思，可以修饰成员变量和成员方法。<br />
●static修饰成员变量表示该成员变量只在内存中只存储一份，可以被共享访问、修改。</p>
<blockquote id="20240124005414-e7endim" updated="20240124005414">
<p id="20240124005414-c34hlm9" updated="20240124005414">被静态变量修饰之后就归属于类</p>
</blockquote>
<p id="20240124005414-hwmrvce" updated="20240124005414">实例化方法归属于 对象</p>
<h3 id="20240124005414-91jj5c9" updated="20240124005414">静态变量</h3>
<pre class="code-block" data-language="Java"><code class="hljs">package staticjingtai;

public class staticpar {

    //静态类型分为两种，

    //静态变量
    public static int jingtai=10;

    //静态方法
    public static void main(String[] args) {

        waibi.user();
    }


}

 class waibi{
 public static void user(){

     //访问变量的两种方法
     //类名.静态变量 ，
     System.out.println(staticpar.jingtai);
     //同一个类中访问静态变量可直接写变量名
     System.out.println(jingtai);
     //对象.静态变量（不推荐使用）低版本中会报错
     staticpar sta=new staticpar();
     int jingtai = sta.jingtai;
     System.out.println(jingtai);


 }


}
/d
</code></pre>
<h4 id="20240124005414-050jziz" updated="20240124005414">静态变量内存区</h4>
<p id="20240124005414-rxk7rm0" updated="20240124005414">可以被全部的对象访问</p>
<p id="20240124005414-l3kp445" updated="20240124005414"><span class="img"><img src="assets/image_f5FQ1zlsKi-20240121141758-57xdr4u.png" alt="image_f5FQ1zlsKi.png" /></span></p>
<h3 id="20240124005414-89o71jx" updated="20240124005414">静态方法</h3>
<ul id="20240124005414-9zfagsr" updated="20240124005414">
<li id="20240124005414-tl2jz68" updated="20240124005414">
<p id="20240124005414-qwu4lke" updated="20240124005414">静态成员方法</p>
</li>
<li id="20240124005414-ll7y1ra" updated="20240124005414">
<p id="20240124005414-ir01le4" updated="20240124005414">实例成员方法</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs"> 
 /实例成员方法
 public void re(){
     
 }
 
 //静态成员方法
 public static void user(){
}
</code></pre>
<h4 id="20240124005414-ib0s5u9" updated="20240124005414">使用场景</h4>
<p id="20240124005414-j2mf6uk" updated="20240124005414">·表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明成实例方法。<br />
·如果该方法是以执行一个共用功能为目的，则可以申明成静态方法。</p>
<h4 id="20240124005414-7hmf2ti" updated="20240124005414">注意事项</h4>
<p id="20240124005414-7h5dopr" updated="20240124005414">·静态方法只能访问静态的成员，不可以直接访问实例成员。（可通过实例化类来访问）<br />
·实例方法可以访问静态的成员，也可以访问实例成员。<br />
●静态方法中是不可以出现this关键字的。</p>
<blockquote id="20240124005414-m4fp32i" updated="20240124005414">
<p id="20240124005414-3qfvylm" updated="20240124005414">this指向该对象，而static并没有对象，只存在堆内存中的静态区/</p>
</blockquote>
<h3 id="20240124005414-dxddg8f" updated="20240124005414">静态工具类代码块</h3>
<blockquote id="20240124005414-5cbbvcb" updated="20240124005414">
<p id="20240124005414-w679ftq" updated="20240124005414">用来写需要重复使用的一些方法例如验证码，方便后续调用</p>
</blockquote>
<p id="20240124005414-c9xxskg" updated="20240124005414">优势在于不用每次都创建对象再访问，从而节省了内存</p>
<pre class="code-block" data-language="Java"><code class="hljs">    static {
        z=6;
    }
</code></pre>
<ul id="20240124005414-5umji0l" updated="20240124005414">
<li id="20240124005414-erlexua" updated="20240124005414">
<p id="20240124005414-80da8kg" updated="20240124005414">禁止构造对象，将构造器私有化。专业写法</p>
</li>
</ul>
<pre class="code-block" data-language="Java"><code class="hljs">  //staticpar.java
  private staticpar() {
    }
</code></pre>
<h3 id="20240124005414-05f17cs" updated="20240124005414">实例工具代码块</h3>
<p id="20240124005414-x652eek" updated="20240124005414">实例化类之后就会调用，在构造函数前调用这个代码块内的代码</p>
<pre class="code-block" data-language="Java"><code class="hljs">{
//代码
int z=6;


}
</code></pre>
<p id="20240124005414-i6wuo14" updated="20240124005414">‍</p>
<h3 id="20240124005414-0g8pwew" updated="20240124005414">理解Main方法</h3>
<p id="20240124005414-75taiup" updated="20240124005414">从根源上理解main方法为什么是这样写</p>
<p id="20240124005414-n3yjg7i" updated="20240124005414">​<span data-type="code">public static void main(String[] args) {} </span>​</p>
<ol id="20240124005414-j0jnqx1" updated="20240124005414">
<li id="20240124005414-p6bq9ji" updated="20240124005414">
<p id="20240124005414-zviv9s7" updated="20240124005414">main方法是由虚拟机调用类中的mian方法，所以要写成public，要不然会调用不到。</p>
</li>
<li id="20240124005414-hniclfi" updated="20240124005414">
<p id="20240124005414-o85umqd" updated="20240124005414">java虚拟机在执行main方法时不必创建对象，所以方法必须是static</p>
</li>
<li id="20240124005414-csm26bv" updated="20240124005414">
<p id="20240124005414-q4c5yx3" updated="20240124005414">该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所<br />
运行的类的参数案例演示，接收参数.</p>
</li>
</ol>
<p id="20240124005414-qvi74fq" updated="20240124005414">‍</p>
<p id="20240124005414-gy4r7ye" updated="20240124005414">‍</p>
<h2 id="20240124005414-apdzlwk" updated="20240124005414">设计模式</h2>
<p id="20240124005414-pqiuuc1" updated="20240124005414">开发中经常遇到一些问题，一个问题通常有种解法的，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。</p>
<ul id="20240124005414-5qwpgue" updated="20240124005414">
<li id="20240124005414-40fpz83" updated="20240124005414">
<p id="20240124005414-lawtkut" updated="20240124005414">该模式用来解决什么问题</p>
</li>
<li id="20240124005414-u3s8zj5" updated="20240124005414">
<p id="20240124005414-6lwhvlh" updated="20240124005414">遇到问题，该模式是怎么写的，如何解决该问题</p>
</li>
</ul>
<h3 id="20240124005414-6icmak7" updated="20240124005414">单例设计模式</h3>
<ol id="20240124005414-ad4vga9" updated="20240124005414">
<li id="20240124005414-hhkvo0p" updated="20240124005414">
<p id="20240124005414-gebvt3c" updated="20240124005414">饿汉式</p>
</li>
<li id="20240124005414-g17vqjx" updated="20240124005414">
<p id="20240124005414-rsh2ik0" updated="20240124005414">懒汉式</p>
</li>
</ol>
<p id="20240124005414-33je1mk" updated="20240124005414">两者的区别是在对象创建的时机，饿汉式是一家在就创建，懒汉式是调用时才创建。</p>
<p id="20240124005414-x6iw7av" updated="20240124005414">在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式。</p>
<blockquote id="20240124005414-9f5e7wo" updated="20240124005414">
<p id="20240124005414-4208775" updated="20240124005414">定义类并且把构造器私有，定义静态变量存储对象，以此对外只提供一个对象，</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">
public class sheji {

    //静态形式共享sheji的实例化对象 instance
    public static sheji instance=new sheji();
    private sheji() {
    }
}


</code></pre>
<p id="20240124005414-zeo98db" updated="20240124005414">在调用后再生成</p>
<pre class="code-block" data-language="Java"><code class="hljs">class last{
    private static last getInstance;

    //定义返回类型是对象
    public static last getInstance(){
        if (getInstance==null){
            getInstance=new last();
        }
    return getInstance;
    }

}
</code></pre>
<p id="20240124005414-y8r5awv" updated="20240124005414">调用方式</p>
<pre class="code-block" data-language="Java"><code class="hljs">class test{
    public static void main(String[] args) {
        //单例模式
        sheji like=sheji.instance;

        //单例模式延迟设计模式
        last kz=last.getInstance();
    }
}/d
</code></pre>
<p id="20240124005414-7atz8m9" updated="20240124005414">‍</p>
<h4 id="20240124005414-gqjs2i3" updated="20240124005414">饿汉式</h4>
<ol id="20240124005414-7knaze1" updated="20240124005414">
<li id="20240124005414-jmehqo6" updated="20240124005414">
<p id="20240124005414-yqmt96i" updated="20240124005414">构造器私有化——&gt;防止new</p>
</li>
<li id="20240124005414-gtx6csv" updated="20240124005414">
<p id="20240124005414-wubd0ze" updated="20240124005414">类的内部创建对象</p>
</li>
<li id="20240124005414-5yfjfmm" updated="20240124005414">
<p id="20240124005414-r5ohz0d" updated="20240124005414">向外暴露静态的公共方法用于获取对象</p>
</li>
</ol>
<blockquote id="20240124005414-ljp9d74" updated="20240124005414">
<p id="20240124005414-s2rsxan" updated="20240124005414">饿汉式：类被加载时就会创建这个对象，不论掉不掉用，所以是饿汉式</p>
<p id="20240124005414-l0guq6c" updated="20240124005414">加载≠实例化</p>
</blockquote>
<pre class="code-block" data-language="java"><code class="hljs">public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;Hello world!&quot;);

//      直接调用,不需要实例化
        IdNumber  id=  IdNumber.getId();
        System.out.println(id);

    }
}

//Single mode
//外部不能创建对象，但是可以调用对象。
class IdNumber{
//    1.定义属性
    private int  PersonAlId;
//  在类的内部创建对象,为了能在静态方法中返回对象，需要修饰为static
    private static IdNumber id=new IdNumber(450122222);

//   2. 定义私有构造器
    private IdNumber(int personAlId) {
        PersonAlId = personAlId;
    }

    @Override
    public String toString() {
        return &quot;IdNumber{&quot; +
                &quot;PersonAlId=&quot; + PersonAlId +
                '}';
    }

    //    向外暴露创建好的对象,加static的目的是为了不创建对象创建方法
    public static IdNumber getId() {
        return id;
    }
}
</code></pre>
<p id="20240124005414-f9c37xp" updated="20240124005414">‍</p>
<p id="20240124005414-ielg40c" updated="20240124005414">‍</p>
<h4 id="20240124005414-cjvg7sf" updated="20240124005414">懒汉式</h4>
<blockquote id="20240124005414-n80oege" updated="20240124005414">
<p id="20240124005414-9l581n2" updated="20240124005414">只有在使用的时候才会去创建这个对象，不是随着类加载而创建。</p>
</blockquote>
<blockquote id="20240124005414-im5pngi" updated="20240124005414">
<p id="20240124005414-0lwipkt" updated="20240124005414">存在线程安装问题，因为多线程执行代码。</p>
</blockquote>
<pre class="code-block" data-language="java"><code class="hljs">//懒汉式

class CreateChat{
    public static String  MessageList=&quot;dasdas&quot;;

    //提前声明CreateChat类方便后续使用
    private static CreateChat ChatStrat;

    private CreateChat(String messageList) {
        MessageList = messageList;
        System.out.println(&quot;创建对象&quot;);
    }

    @Override
    public String toString() {
        return &quot;CreateChat{&quot; +
                &quot;MessageList='&quot; + MessageList + '\'' +
                '}';
    }

    //    只有在调用getInstance时才会创建对象并且返回
    public static CreateChat getInstance(){
        if (ChatStrat==null){
            ChatStrat= new CreateChat(&quot;mwqe&quot;);
        }
        return  ChatStrat;
    }

}
</code></pre>
<p id="20240124005414-z8w9afo" updated="20240124005414">‍</p>
<p id="20240124005414-d6a3pjn" updated="20240124005414">‍</p>
<p id="20240124005414-yjhvgtc" updated="20240124005414">‍</p>
<h2 id="20240124005414-75wkqni" updated="20240124005414">面向对象核心2：继承</h2>
<blockquote id="20240124005414-4j3xa1p" updated="20240124005414">
<p id="20240124005414-hffbwhc" updated="20240124005414">继承是两个建立父子关系然后继承另一个类的成员方法和成员变量</p>
</blockquote>
<p id="20240124005414-f9jav0b" updated="20240124005414">解决重复代码，一次编写一直可以调用，增强类的功能扩展性</p>
<p id="20240124005414-bcls6a8" updated="20240124005414">语法</p>
<pre class="code-block" data-language="Java"><code class="hljs"> 子类 extends 父类
 classmate extends student
</code></pre>
<blockquote id="20240124005414-9twbdfm" updated="20240124005414">
<p id="20240124005414-zinkw7p" updated="20240124005414">📌继承后就可以当自己的方法直接进行调用</p>
</blockquote>
<p id="20240124005414-w51av39" updated="20240124005414">test类</p>
<pre class="code-block" data-language="Java"><code class="hljs">public class test {
    public static void main(String[] args) {
        extdents testt=new extdents();
        testt.setName(&quot;张三&quot;);
        testt.priname();
    }
}
</code></pre>
<p id="20240124005414-p33yrp3" updated="20240124005414">extendts类</p>
<pre class="code-block" data-language="Java"><code class="hljs">public class extdents extends student  {

    public void priname(){
        System.out.println(&quot;名字是&quot;+getName());
    }

}
</code></pre>
<p id="20240124005414-1x83nxg" updated="20240124005414">student类</p>
<pre class="code-block" data-language="Java"><code class="hljs">package extendsstudy;

public class student {
     private   String name;
     private   int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

</code></pre>
<h3 id="20240124005414-qr62yo5" updated="20240124005414">继承内存原理</h3>
<blockquote id="20240124005414-3408ify" updated="20240124005414">
<p id="20240124005414-tlyvdw1" updated="20240124005414">调用时实例化后在内存中当做一个对象来看 ，但在内部还是单独当做两个对象来看</p>
</blockquote>
<p id="20240124005414-86rbs5w" updated="20240124005414">父类是 super</p>
<p id="20240124005414-7klpta6" updated="20240124005414">子类是 this</p>
<p id="20240124005414-6yacc75" updated="20240124005414">一旦继承就会继承全部的方法和变量，所以父类中的成员的添加要谨慎</p>
<p id="20240124005414-nsom2ni" updated="20240124005414"><span class="img"><img src="assets/image_vwxLFdiTre-20240121141758-o14ldwl.png" alt="image_vwxLFdiTre.png" /></span></p>
<h3 id="20240124005414-49ytpwq" updated="20240124005414">继承的特点</h3>
<p id="20240124005414-8fnebx2" updated="20240124005414">①子类可以继承父类的属性和行为，但是子类不能继承父类的构造器<br />
②Java是单继承模式：一个类只能继承一个直接父类。<br />
③Java不支持多继承、但是支持多层继承。<br />
④Java中所有的类都是Object类的子类</p>
<blockquote id="20240124005414-4ag08x0" updated="20240124005414">
<p id="20240124005414-wm4puzy" updated="20240124005414">📌子类其实是可以继承父类的私有方法，只是不能调用，也可以说是不能继承（有争议）</p>
</blockquote>
<blockquote id="20240124005414-dh1kl33" updated="20240124005414">
<p id="20240124005414-7246jag" updated="20240124005414">📌静态成员不算继承，因为是共享的只有一份在静态区中所有方法都可以访问</p>
</blockquote>
<blockquote id="20240124005414-hk03o1h" updated="20240124005414">
<p id="20240124005414-xbe68z1" updated="20240124005414">📌多层继承如果有冲突（有相同的方法）会优先调用继承关系近的类。</p>
</blockquote>
<h3 id="20240124005414-fuqz12r" updated="20240124005414">Super父类访问关键词</h3>
<blockquote id="20240124005414-zne6uc4" updated="20240124005414">
<p id="20240124005414-rjwfqcf" updated="20240124005414">在子类中访问时，当父类和子类的成员冲突时，默认访问继承关系近的子类，但也可以使用super来访问父类的</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">package extends_confli;

public class test {
    public static void main(String[] args) {
        dog d1=new dog();
        d1.getname();
    }
}

class Animal{
    String name=&quot;动物&quot;;

}

class dog extends Animal{
    String name=&quot;狗&quot;;
    public  void getname() {
        //默认是输出子类的name
        System.out.println(this.name);
        //访问父类的name
        System.out.println(super.name);
    }

}

》》
》狗
》动物
</code></pre>
<h3 id="20240124005414-lnj09zz" updated="20240124005414">继承时的方法重写</h3>
<blockquote id="20240124005414-qtoiobp" updated="20240124005414">
<p id="20240124005414-qb8zcc5" updated="20240124005414">在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。</p>
</blockquote>
<p id="20240124005414-v01tk66" updated="20240124005414">●当子类需要父类的功能，但父类的该功能不完全满足自己的需求时。<br />
●子类可以重写父类中的方法。</p>
<h4 id="20240124005414-094da8k" updated="20240124005414">@override重写注解</h4>
<blockquote id="20240124005414-0jb3qjj" updated="20240124005414">
<p id="20240124005414-60j4sld" updated="20240124005414">在方法重写时 加上@override 1、重写校验注解，加上之后，这个方法必须是正确重写的，这样更安全。2、提高程序的可读性，代码优雅！</p>
</blockquote>
<blockquote id="20240124005414-3zsi5ez" updated="20240124005414">
<p id="20240124005414-6pl9l6j" updated="20240124005414">📌继承下方法重写时 方法名称 和形参列表必须一样</p>
</blockquote>
<blockquote id="20240124005414-pn0x2pw" updated="20240124005414">
<p id="20240124005414-kdlq3om" updated="20240124005414">📌私有方法不能被重写</p>
</blockquote>
<blockquote id="20240124005414-nf9czua" updated="20240124005414">
<p id="20240124005414-b51y7bn" updated="20240124005414">📌子类重写父类方法时，访问权限必须大于或者等于父类（暂时了解：缺省&lt;protected&lt;public)</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">package extends_confli;

public class test {
    public static void main(String[] args) {
        dog d1=new dog();
        d1.getname();
        d1.run();
    }
}

class Animal{
    String name=&quot;动物&quot;;
    public void run(){
        System.out.println(&quot;跑得很快&quot;);
    }

}

class dog extends Animal{
    String name=&quot;狗&quot;;
    public  void getname() {
        //默认是输出子类的name
        System.out.println(this.name);
        //访问父类的name
        System.out.println(super.name);
    }
    @Override
    public void run(){
        super.run();
        System.out.println(&quot;跑的特别快&quot;);
    }

}


</code></pre>
<h3 id="20240124005414-r3zef4p" updated="20240124005414">构造器访问</h3>
<p id="20240124005414-0hmtrp4" updated="20240124005414">继承时 子类会先访问父类的无参构造器，,子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己。</p>
<p id="20240124005414-yo4hy0k" updated="20240124005414">子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。<br />
子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。</p>
<blockquote id="20240124005414-ll327pa" updated="20240124005414">
<p id="20240124005414-4hjo6as" updated="20240124005414">📌子类构造器中 默认存在  super()  自动添加的，执行后马上调用父类</p>
</blockquote>
<pre class="code-block" data-language="Java"><code class="hljs">package extends_confli;

public class extends_constr {
    public static void main(String[] args) {
        dogz d1=new dogz();
                d1.show();
    }
}

class Animalz{
    public Animalz() {
        System.out.println(&quot;父类无参构造器被调用&quot;);
    }
}

class dogz extends Animalz{
    public dogz(){

        System.out.println(&quot;子类构造器被调用&quot;);
    }
    public void show(){


    }

}
</code></pre></div>
<script src="appearance/icons/material/icon.js?2.12.3"></script>
<script src="stage/build/export/protyle-method.js?2.12.3"></script>
<script src="stage/protyle/js/lute/lute.min.js?2.12.3"></script>    
<script>
    window.siyuan = {
      config: {
        appearance: { mode: 1, codeBlockThemeDark: "base16/dracula", codeBlockThemeLight: "github" },
        editor: { 
          codeLineWrap: true,
          fontSize: 16,
          codeLigatures: false,
          plantUMLServePath: "https://www.plantuml.com/plantuml/svg/~1",
          codeSyntaxHighlightLineNum: true,
          katexMacros: JSON.stringify({}),
        }
      },
      languages: {copy:"复制"}
    };
    const previewElement = document.getElementById('preview');
    Protyle.highlightRender(previewElement, "stage/protyle");
    Protyle.mathRender(previewElement, "stage/protyle", false);
    Protyle.mermaidRender(previewElement, "stage/protyle");
    Protyle.flowchartRender(previewElement, "stage/protyle");
    Protyle.graphvizRender(previewElement, "stage/protyle");
    Protyle.chartRender(previewElement, "stage/protyle");
    Protyle.mindmapRender(previewElement, "stage/protyle");
    Protyle.abcRender(previewElement, "stage/protyle");
    Protyle.htmlRender(previewElement);
    Protyle.plantumlRender(previewElement, "stage/protyle");
    document.querySelectorAll(".protyle-action__copy").forEach((item) => {
      item.addEventListener("click", (event) => {
            let text = item.parentElement.nextElementSibling.textContent.trimEnd();
            text = text.replace(/ /g, " "); // Replace non-breaking spaces with normal spaces when copying
            navigator.clipboard.writeText(text);
            event.preventDefault();
            event.stopPropagation();
      })
    });
</script></body></html>